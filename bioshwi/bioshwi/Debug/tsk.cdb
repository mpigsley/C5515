//! 
//# c5505.cdb 5.25.44

object VECT :: MEM {
    param iComment :: "This object defines space for the DSP's interrupt vectors and can't be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "MEM"
    param iDelMsg :: "This object defines space for the DSP's interrupt vectors and can't be deleted"
    param base :: 32640
    param len :: 128
    param iAllocHeap :: 0
    param iHeapSize :: 16336
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (if self.gNumOf > 0 {1} else {0})
    prop NoGen :: 0
    prop IsDirty :: ($a = self.gDirty, self.gDirty = 0, $a)
    prop dataSize :: 0
    prop error :: # ("Error: ", self.name, $1)
    prop warning :: ("Warning ...", self.name, $1)
    prop minBit :: ($a = 0, while (($1 & (1 << $a)) && $a < 32) {++$a}, $a)
    prop name :: ("<unnamed module>")
    prop numBit :: ($a = $b = 0, while ($a < 32) {if ($1 & (1 << $a)) {++$b} }, $b)
}

class ObjectMgr {
    isa Module
    prop CanCreate :: (if (self.gNumOf < self.maxObjs()) {self.localCanCreate()} else {self.warning("Maximum number of objects already created")})
    prop CanDelete :: (if (self.iDelMsg == "ok" || (self.iDelUser == self.gUser)) {if (self.iId >= 0 && self.iIsUsed) {self.localCanDelete()} else {self.warning("Object already deleted")}} else {self.warning(self.iDelMsg)})
    prop Create :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanCreate()) == "ok") {if (($a = self.localCreate()) == "ok") {if (self.iIsUsed == 0) {self.mkId(if $0 > 1 {$2} else {-1}), self.iIsUsed = 1, GlobalStatus.gDirty = 1, self.gDirty = 1} } } , (self.gUser = "USER"), $a)
    prop Delete :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanDelete()) == "ok") {if (($a = self.localDelete()) == "ok") {self.rmId(self.iId), self.iIsUsed = 0, GlobalStatus.gDirty = 1, self.gDirty = 1} } , (self.gUser = "USER"), $a)
    prop GetSetOf :: (self.gSetOf)
    prop GetNumOf :: (self.gNumOf)
    prop GetObjId :: (self.iId)
    prop GetPriority :: (self.iId)
    prop SetPriority :: (self.iId = $1)
    prop IsConfObj :: (self.iIsUsed)
    prop localCanCreate :: ("ok")
    prop localCanDelete :: ("ok")
    prop localCreate :: ("ok")
    prop localDelete :: ("ok")
    prop localInit :: (0)
    prop isFinite :: (if self.maxObjs() <= GBL.DSPWORDSIZE {1} else {0})
    prop mkId :: (if (self.isFinite()) {if ($1 < 0) {self.iId = self.minBit(self.gSetOf)} else {self.iId = $1}, (self.gSetOf |= (1 << self.iId))} else {self.iId = 0}, ++self.gNumOf, self.iId)
    prop rmId :: (if (self.isFinite()) {self.gSetOf &= ~(1 << self.iId)} , --self.gNumOf)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop isDriver :: (0)
    prop SortChildHierView :: (1)
}

type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (100)
    prop GlobalPropertyPage :: ("{9D3AD931-847B-11d0-A621-0000C070F3E9}")
    prop Status :: (# self.SeedVersion, # self.MinStackSize, # self.SysDataSize)
    global GENLIB :: "bioscfg.dll" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generation Library"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    global DATE :: "Fri Apr 25 11:41:58 2014" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GCONFVERS :: "@(#)*** xdcutils-g09" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SysDataSize :: = ($a = 0, scan ($i; nil) {if ($i.dataSize() != nil) {$a = $a + $i.dataSize()} }, $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Estimated Data Size: %d"
        prop StatusField :: 1
        prop NoGen :: 1
    }
    global MinStackSize :: = ($a = ((2) + (((2) + (4) + (2) + (2)))), $a = $a + ((1) + (((2) + (4) + (2) + (2)))), $a = $a + (0), $b = 0, scan ($i; CLK) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((((5) + (2) + (12) + (14))) + (2) + (((2) + (4) + (2) + (2)))) * $b), $b = 0, scan ($i; HWI) {if ($i.IsConfObj()) {if ($i != HWI_RESET) {if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {$b++} } } }, $a = $a + (((2) + (10) + (6)) * $b), $b = 0, scan ($i; SWI) {if ($i.IsConfObj()) {if ($i.priority > $b) {$b = $i.priority} } }, $a = $a + (((((2) + (10) + (6))) + (((((5) + (2) + (12) + (14))) + (2))) + (((6) + (((2) + (4) + (2) + (2)))))) * $b), $b = 0, scan ($i; PRD) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2) + (((2) + (4) + (2) + (2)))) * $b), $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Est. Min. Stack Size (MAUs): %d"
        prop StatusField :: 1
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ConfigWarnings :: = (if (self.MinStackSize > MEM.STACKSIZE) {"Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."} else {"None"}) { 
        prop Label :: "Warnings"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SeedVersion :: = "@(#)*** cuda-u44x" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

class EModule {
    isa Module
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class ModuleFolder {
    isa Module
    prop NoGen :: 1
}

type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (500)
    prop GlobalPropertyPage :: ("{B936FB91-52A5-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (501)
    prop GlobalPropertyPage :: ("{053C8F90-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (502)
    prop GlobalPropertyPage :: ("{053C8F91-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (503)
    prop GlobalPropertyPage :: ("{053C8F92-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (504)
    prop GlobalPropertyPage :: ("{053C8F93-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (505)
    prop GlobalPropertyPage :: ("{A2BCEC70-5365-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type PROJ {
    isa ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (201)
    prop GlobalHelpTopic :: (101)
    prop InstancePropertyPage :: ("{AC3C77D1-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D2-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ALIASALL :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate C Names for All Objects"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global IGNOREWARNING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Ignore Warnings"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Include File Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global OBJDIR :: "." { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object file directory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTEXE :: "out" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Executable File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTLIB :: "lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTASM :: "asm" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Assembly Language Source File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTOBJ :: "obj" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst projType :: "Executable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Executable,Library"
        prop Label :: "Target Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst projName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst useRpt :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RPT Instruction"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst minimizeSpace :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Optimize for Space over Time"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst tmx :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Avoid TMX Silicon Bugs"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    prop Label :: "Project File Manager"
    prop InstanceHelpTopic :: (BIOSHELP_PROJ_FILE_INSTANCE)
    prop GlobalHelpTopic :: (BIOSHELP_PROJ_FILE_GLOBAL)
    prop InstancePropertyPage :: ("{AC3C77D3-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D4-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst elemType :: "C Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C Source,ASM Source,Library,Linker Command File"
        prop Label :: "Input File Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Input File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "register,register+local,register+local+global,register+local+global+file"
        prop Label :: "Optimization Level"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst inline :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Inline Expansion"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst definitions :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Additional Definitions"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst iParent :: 0 { 
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: "%10S\nSECTIONS {%4t\n.vers block(0x20000) (COPY): {} /* version information */%0t\n}\n\n--\"diag_suppress=10286\" /* new linker needs new BIOS (SDSCM00026767) */\n\n--\"diag_suppress=16002\"\n-priority\n%1S-l%2S%3S\n%16S%4S%17S%15S%5S%6S%12S%7S%18S\n%19S\n%20S\n\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, bios55xxLibStr, _chipStr, _sioLibStr, _pwrmLibStr, _pslLibStr1, _pslLibStr2, _dspSubTypeStr, _pslConfigLibStr, _instStr, _rtsNameStr"
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
    prop GlobalHelpTopic :: (103)
    prop InstanceHelpTopic :: (103)
    prop InstancePropertyPage :: ("{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}")
    prop localInit :: (RTA_toHost.Create("HST"), RTA_toHost.bufseg = HST.OBJMEMSEG, RTA_fromHost.Create("HST"), RTA_fromHost.bufseg = HST.OBJMEMSEG, RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"))
    prop chipcall :: ("ok")
    prop IsConfMod :: 1
    prop ucompare :: ($e = "ok", $a = ($1 >> 31) & 0x00000001, $b = ($2 >> 31) & 0x00000001, $c = $1 & 0x7fffffff, $d = $2 & 0x7fffffff, if ($a > $b) {$e = "gt"} else {if ($a == $b) {if ($c > $d) {$e = "gt"} else {if ($c == $d) {$e = "eq"} else {$e = "lt"}}} else {$e = "lt"}}, $e)
    prop L2Check :: (if (self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711) {self.PCC = "mapped", if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} , self.L2CacheSizeCheck()} else {if (self.DSPSUBTYPE == 6400) {self.PCC = "mapped", if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} , self.L2CacheSizeCheck()} else {if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0, self.L2CacheSizeCheck()} else {if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0, self.L2CacheSizeCheck()} }}})
    prop C621xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C621XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "SRAM") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "1-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000, CACHE_L2.len = 0x4000} else {if (self.L2MODEOPTS == "2-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.L2MODEOPTS == "3-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000, CACHE_L2.len = 0xc000} else {if (self.L2MODEOPTS == "4-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} }}}}}, $e)
    prop C641xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C641XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (0k)") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C641XL2MODEOPTS == "4-way cache (256k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} }}}}}, $e)
    prop C64PL1PCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1PCFG = "32k", CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {if (self.C64PL1PCFG == "0k") {CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0, CACHE_L1P.len = 0x0, CACHE_L1P.Delete("MEM")} else {if (self.C64PL1PCFG == "4k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000, CACHE_L1P.len = 0x1000} else {if (self.C64PL1PCFG == "8k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000, CACHE_L1P.len = 0x2000} else {if (self.C64PL1PCFG == "16k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000, CACHE_L1P.len = 0x4000} else {if (self.C64PL1PCFG == "32k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL1DCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1DCFG = "32k", CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {if (self.C64PL1DCFG == "0k") {CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0, CACHE_L1D.len = 0x0, CACHE_L1D.Delete("MEM")} else {if (self.C64PL1DCFG == "4k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000, CACHE_L1D.len = 0x1000} else {if (self.C64PL1DCFG == "8k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000, CACHE_L1D.len = 0x2000} else {if (self.C64PL1DCFG == "16k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000, CACHE_L1D.len = 0x4000} else {if (self.C64PL1DCFG == "32k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL2CacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "0k") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "32k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C64PL2MODEOPTS == "64k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C64PL2MODEOPTS == "128k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C64PL2MODEOPTS == "256k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} else {if (self.C64PL2MODEOPTS == "512k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x80000, CACHE_L2.len = 0x80000} else {if (self.C64PL2MODEOPTS == "1024k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x100000, CACHE_L2.len = 0x100000} else {$e = self.error("Unknown cache size")}}}}}}}}, $e)
    prop L2CacheSizeCheck :: ($e = "ok", scan ($i; MEM) {if ($i == CACHE_L2) {if self.C621XL2CONFIGURE {$e = self.C621xL2CacheSizeCheck()} else {if self.C641XL2CONFIGURE {$e = self.C641xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711 {$e = self.C621xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6400 {$e = self.C641xL2CacheSizeCheck()} else {{CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")}}}}}} }, $e)
    prop setCPUClock :: ($e = "ok", if ($1 != self.CPUCLOCK) {$a = self.CPUCLOCK, self.CPUCLOCK = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.CPUCLOCK = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    prop setBootFxn :: (if self.CPUREVISION == "1.2" {@_FXN_F_nop} else {if self.CPUREVISION == "2.0" {@_FXN_F_nop} else {@_FXN_F_nop}})
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (if (HST.RTDX == 1) {"lnkrtdx"} else {if (HST.DSM == 1) {"lnkdsm"} else {if (HST.EVM54 == 1) {"lnkevm54"} else {if (HST.BIOSLINK == 1) {"lnkbioslink"} else {"lnknone"}}}})
    prop _dsptype :: GBL.DSPTYPE
    prop _instStr :: if self.INSTRUMENTED {""} else {"_NONINST"}
    prop _rtsNameStr :: (self.RTSLIB)
    prop _biosLibStr :: "-lbios%23S%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: if self.MEMORYMODEL == "SMALL" {""} else {"x"}
    prop _librarySuffix :: if self.MEMORYMODEL == "SMALL" {".a55"} else {if self.MEMORYMODEL == "LARGE" {".a55L"} else {if self.DSPSUBTYPE != 5599 {".a55H"} else {".a55Pb"}}}
    prop _rtdxLibStr :: (if (RTDX.USERTDX == 0) {""} else {if (RTDX.RTDXTYPE == "JTAG") {if (self.MEMORYMODEL == "SMALL") {"-lrtdx.lib %24t/* RTDX JTAG support */%0t\n"} else {if (self.MEMORYMODEL == "LARGE") {"-lrtdxx.lib %24t/* RTDX JTAG support */%0t\n"} else {if (self.MEMORYMODEL == "HUGE") {if (self.DSPSUBTYPE != 5599) {"-lrtdxh.lib %24t/* RTDX JTAG support */%0t\n"} else {self.error("RTDX not supported for 55+ yet. Disable RTDX.")}} }}} else {if (RTDX.RTDXTYPE == "Simulator") {if (self.MEMORYMODEL == "SMALL") {"-lrtdxsim.lib %24t/* RTDX SIM support */%0t\n"} else {if (self.MEMORYMODEL == "LARGE") {"-lrtdxsimx.lib %24t/* RTDX SIM support */%0t\n"} else {if (self.MEMORYMODEL == "HUGE") {"-lrtdxsimh.lib %24t/* RTDX SIM support */%0t\n"} }}} }})
    prop _rtsLibStr :: (if self.SPECIFYRTSLIB {"-l%24S%24t/* C and C++ run-time library support */%0t\n"} else {if self.MEMORYMODEL == "SMALL" {"-lrts55.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.MEMORYMODEL == "LARGE" {"-lrts55x.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE != 5599 {"-lrts55h.lib%24t/* C and C++ run- time library support */%0t\n"} else {"-lrts55phb.lib%24t/* C and C++ run-time library support */%0t\n"}}}})
    prop bios55xxLibStr :: ("-lbios5505%8S %24t/* 5505 and compatible chips */%0t\n")
    prop _chipStr :: ""
    prop _pmiLibStr :: ""
    prop _pmiVoltLibStr :: ""
    prop _pmiVoltControlLibStr :: ""
    prop _psclLibStr :: ""
    prop _psclCfgLibStr :: ""
    prop _psclConfigLibStr :: ""
    prop _pwrmLibStr :: if PWRM.PWRM_ENABLE == 1 {(if self.MEMORYMODEL == "SMALL" {"-lpwrm.a55"} else {if self.MEMORYMODEL == "LARGE" {"-lpwrm.a55L"} else {"-lpwrm.a55H"}})} else {""}
    prop _pslLibStr1 :: if PWRM.PWRM_ENABLE == 1 {if PWRM.PWRM_SCALING == 1 {if self.DSPSUBTYPE == 5509 {"-lPSL_c%21da%8S %24t/* PSL library */%0t"} else {"-lPSL_c%21d%8S %24t/* PSL library */%0t"}} else {"-lpslnull%8S %24t/* PSL library */%0t"}} else {""}
    prop _pslLibStr2 :: if PWRM.PWRM_SCALING == 1 {"-l%22S %24t/* PSL configuration library */%0t"} else {""}
    prop _dspSubTypeStr :: self.DSPSUBTYPE * 1
    prop _pslConfigLibStr :: PWRM.PWRM_CONFIGLIB
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (if (MEM.LNKCMDFILE == "") {""} else {"-l%11S %24t/* User Specified Linker cmd file */%0t\n"})
    prop _sioLibStr :: if SIO.USEISSUERECLAIM == 1 {"-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n"} else {"-lsioboth%8S %24t/* supports both SIO models */%0t\n"}
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: ""
    prop AllocType :: (if (self.SUPPORTCSL) {"1\0,    _cslAllocDesc, _cslmemSeg, _placement"} )
    prop _cslAllocDesc :: ("%8t .csldata: block(0x20000) {%12t\n *(.csldata)%8t\n }")
    prop _cslmemSeg :: MEM.BSSSEG
    prop _placement :: (0x7fffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRODUCT :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop EnvField :: 1
    }
    global CALLBACKOBJ :: CLK { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c5505" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CPUCLOCK :: 200.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CLKIN :: = 20000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: 100000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MIPS :: 100.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = self.MIPS, $b = if (GBL.DSPTYPE == 62) {$1} else {$1 * 2}, $e = "ok", self.MIPS = $1, self.FREQ = int(self.MIPS * 1000), if (($e = self.setCPUClock($b)) != "ok") {self.MIPS = $a} , $e)
    }
    global OSTYPE :: "BIOS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPTYPE :: 55 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global SPECIFYRTSLIB :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    global RTSLIB :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: self.SPECIFYRTSLIB
    }
    global DSPSUBTYPE :: 5505 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "5505"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CLKTYPE :: 5505 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CLK Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CHIPTYPE :: "other" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "5505,custom,other"
        prop JSName :: "CHIPTYPE"
        prop Label :: "Chip Support Library (CSL)"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (if ($1 == "5509") {self.DSPSUBTYPE = 5509, self.CPUREVISION = "1.2"} else {if ($1 == "5509A") {self.DSPSUBTYPE = 5509, self.CPUREVISION = "1.2"} else {if ($1 == "5510PG2_2") {self.DSPSUBTYPE = 5510, self.CPUREVISION = "2.2"} else {if ($1 == "5510PG2_1") {self.DSPSUBTYPE = 5510, self.CPUREVISION = "2.1"} else {if ($1 == "5510PG2_0") {self.DSPSUBTYPE = 5510, self.CPUREVISION = "2.0"} else {if ($1 == "5510PG1_2") {self.DSPSUBTYPE = 5510, self.CPUREVISION = "1.2"} }}}}}, self.CHIPTYPE = $1, $e = "ok", if (GBL.CHIPCHAIN != nil) {$e = GBL.CHIPCHAIN.chipcall()} , if (GBL.DSPSUBTYPE != 5503 && GBL.DSPSUBTYPE != 5507 && GBL.DSPSUBTYPE != 5509) {PWRM.PWRM_DEVICEINIT = 0, PWRM.PWRM_RESOURCETRACKING = 0} , if (GBL.DSPSUBTYPE != 5503 && GBL.DSPSUBTYPE != 5507 && GBL.DSPSUBTYPE != 5509 && GBL.DSPSUBTYPE != 5510) {PWRM.PWRM_ADAPTCLK = 0, PWRM.PWRM_SCALING = 0} , if (GBL.DSPSUBTYPE == 5509) {PWRM.PWRM_CACHE = 1, PWRM.PWRM_DS_CACHE = 1} , $e)
    }
    global DISPCALLCSLCFGINIT :: = (self.CHIPTYPE != "other" && self.CHIPTYPE != "custom") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: self.SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C5505" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MODIFYCLKMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: if GBL.DSPSUBTYPE == 5502 {"Modify PLL Registers"} else {"Modify CLKMD"}
        prop JSName :: "MODIFYCLKMD"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {0} else {if GBL.DSPSUBTYPE == 1510 {0} else {if GBL.DSPSUBTYPE == 2420 {0} else {if GBL.DSPSUBTYPE == 2320 {0} else {if GBL.DSPSUBTYPE == 5505 {0} else {1}}}}}
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.MODIFYCLKMD) {self.MODIFYCLKMD = $1} , "ok")
    }
    global CLKMD :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: if GBL.DSPSUBTYPE == 5502 {"PLLCSR - PLL Control/Status Register"} else {"CLKMD - (PLL) Clock Mode Register"}
        prop JSName :: "CLKMD"
        prop Visible :: if GBL.DSPSUBTYPE == 5502 {0} else {if GBL.DSPSUBTYPE == 5561 {0} else {if GBL.DSPSUBTYPE == 1510 {0} else {if GBL.DSPSUBTYPE == 2420 {0} else {if GBL.DSPSUBTYPE == 2320 {0} else {if GBL.DSPSUBTYPE == 5802 {0} else {if GBL.DSPSUBTYPE == 5505 {0} else {1}}}}}}}
        prop Writable :: self.MODIFYCLKMD
        prop NoGen :: 0
    }
    global PLLM :: 15 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLM - PLL Multiplier Control Register"
        prop JSName :: "PLLM"
        prop Visible :: if GBL.DSPSUBTYPE == 5502 {1} else {0}
        prop Writable :: self.MODIFYCLKMD
        prop NoGen :: 0
    }
    global PLLDIV0 :: 32768 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLDIV0 - PLL Divider 0 Register"
        prop JSName :: "PLLDIV0"
        prop Visible :: if GBL.DSPSUBTYPE == 5502 {1} else {0}
        prop Writable :: self.MODIFYCLKMD
        prop NoGen :: 0
    }
    global PLLDIV1 :: 32771 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLDIV1 - PLL Divider 1 Register"
        prop JSName :: "PLLDIV1"
        prop Visible :: if GBL.DSPSUBTYPE == 5502 {1} else {0}
        prop Writable :: self.MODIFYCLKMD
        prop NoGen :: 0
        prop Set :: ($e = "ok", if ($1 != self.PLLDIV1) {$a = self.PLLDIV1, self.PLLDIV1 = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.PLLDIV1 = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    }
    global DSPARITHMETIC :: = (if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {"FLOAT"} else {"FIXED"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {32} else {16}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (if GBL.DSPTYPE == 62 {8} else {if GBL.DSPSUBTYPE == 5599 {8} else {GBL.DSPWORDSIZE}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DATAPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {16} else {if (GBL.DSPTYPE == 55) {if (GBL.MEMORYMODEL == "SMALL") {16} else {23}} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {if (GBL.CALLMODEL == "near") {16} else {24}} else {if (GBL.DSPTYPE == 55) {24} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MEMORYMODEL :: "LARGE" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SMALL,LARGE,HUGE"
        prop Label :: "Memory Model"
        prop JSName :: "MEMORYMODEL"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.MEMORYMODEL = $1, "ok")
    }
    global AUTOINIT :: "ROM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.USERINITFXN = @_FXN_F_nop, self.USERINIT = $1} else {self.USERINIT = $1}, "ok")
    }
    global USERINITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: self.USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENABLEINST :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEINST) {if ($1) {RTA_toHost.Create("HST"), RTA_toHost.bufseg = HST.OBJMEMSEG, RTA_fromHost.Create("HST"), RTA_fromHost.bufseg = HST.OBJMEMSEG, RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE} else {RTA_toHost.Delete("HST"), RTA_toHost.bufseg = MEM_NULL, RTA_fromHost.Delete("HST"), RTA_fromHost.bufseg = MEM_NULL, RTA_dispatcher.Delete("HST"), IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0}, self.ENABLEINST = $1} , "ok")
    }
    global INSTRUMENTED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLEDLL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LARGEMODEL :: = if self.MEMORYMODEL == "LARGE" {1} else {if self.MEMORYMODEL == "HUGE" {2} else {0}} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global ENABLEICACHE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable I-Cache Programming"
        prop JSName :: "ENABLEICACHE"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEICACHE) {self.ENABLEICACHE = $1} , "ok")
    }
    global CACHETYPE :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Nogen :: 0
    }
    global ICACHE :: "2-Way Two RAMset" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "2-Way no RAMset,2-Way One RAMset,2-Way Two RAMset"
        prop Label :: "I-cache configuration"
        prop JSName :: "ICACHE"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: if self.ENABLEICACHE == 1 {1} else {0}
        prop NoGen :: 1
        prop Set :: (self.ICACHE = $1, if (self.ICACHE == "2-Way no RAMset") {self.CACHETYPE = 0, "ok"} else {if (self.ICACHE == "2-Way One RAMset") {self.CACHETYPE = 1, "ok"} else {self.CACHETYPE = 2, "ok"}})
    }
    global CACHEICRTAG1 :: 16252928 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x20
        prop Label :: "ICRTAG1 address (24bit address)"
        prop JSName :: "CACHEICRTAG1"
        prop Format :: "0x%06x"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: if ((self.ICACHE != "2-Way no RAMset") && (self.ENABLEICACHE == 1)) {1} else {0}
        prop NoGen :: 0
    }
    global CACHEICRTAG2 :: 16257024 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x20
        prop Label :: "ICRTAG2 address (24bit address)"
        prop JSName :: "CACHEICRTAG2"
        prop Format :: "0x%06x"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: if ((self.ICACHE == "2-Way Two RAMset") && (self.ENABLEICACHE == 1)) {1} else {0}
        prop NoGen :: 0
    }
    global SUPPORTCSL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.TRCMASKVALUE = 0xDBEF} else {self.TRCMASKVALUE = 0x4000}, self.ENABLEALLTRC = $1, "ok")
    }
    global TRCMASKVALUE :: 56303 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT :: = self.DISPCALLCSLCFGINIT { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global BIOS_BOOTFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "BIOS boot function"
        prop JSName :: "BIOS_BOOTFXN"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DCRPOSTEDWRITE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DPORT write in posted mode"
        prop JSName :: "DCRPOSTEDWRITE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.DCRPOSTEDWRITE = $1} else {self.DCRPOSTEDWRITE = $1}, "ok")
    }
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (108)
    prop InstanceHelpTopic :: (208)
    prop InstancePropertyPage :: ("{3D658E70-05E7-11d0-BD44-0020AFEE33C8}")
    prop GlobalPropertyPage :: ("{3D658E71-05E7-11d0-BD44-0020AFEE33C8}")
    prop heapLabelStr :: (self.iHeapId)
    prop _cmd55stksz :: (MEM.STACKSIZE * 2)
    prop _cmd55systksz :: (MEM.SYSSTACKSIZE * 2)
    prop _cmd55origin :: (self.base * 2)
    prop _cmd55len :: (self.len * 2)
    prop _cmd55heapsize :: (self.iHeapSize * 2)
    prop _cmd55heaplen :: (self.iHeapSize * 2)
    prop GenLinkPrologue :: (if (GBL.DSPTYPE == 55) {"-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"} else {"-stack 0x%1x\nMEMORY {%4t\0, _stackSize"})
    prop _stackSize :: MEM.STACKSIZE
    prop _sysstackSize :: MEM.SYSSTACKSIZE
    prop _sysstackSeg :: MEM.SYSSTACKSEG
    prop _sysstackSegPg :: (if MEM.SYSSTACKSEG.space() == "code" {" PAGE 0"} else {if MEM.SYSSTACKSEG.space() == "data" {" PAGE 1"} else {if MEM.SYSSTACKSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})
    prop AllocType :: (if (self.REUSE == 0 && self.USERCMD == 0) {"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 0 && self.USERCMD == 1) {"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 1 && self.USERCMD == 0) {"18\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"}}})
    prop _firstPlace :: 0
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace :: (0x7fffff / 2)
    prop _sysinitPlace :: (0x7fffff / 2)
    prop _argsString :: ("%8t .args: align = 0x4  fill=0 block(0x20000) {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString :: ("%8t .bss: block(0x20000)    {}")
    prop _farString :: ("%8t .far:     {}")
    prop _cinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CINITSEG == MEM.LOADCINITSEG) {"%8t .cinit: block(0x20000)    {}"} else {"%8t .cinit:   {} load > %1s%2s, run\0, _loadcinitSeg, _cinitpg"}} else {"%8t .cinit: block(0x20000)    {}"})
    prop _pinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.PINITSEG == MEM.LOADPINITSEG) {"%8t .pinit: block(0x20000)    {}"} else {"%8t .pinit:   {} load > %1s%2s, run\0, _loadpinitSeg, _pinitpg"}} else {"%8t .pinit: block(0x20000)    {}"})
    prop _trcinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {"%8t .trcdata:   {}"} else {"%8t .trcdata:   {} load > %1s%2s, run\0, _loadtrcinitSeg, _trcdatapg"}} else {"%8t .trcdata:    {}"})
    prop _gblinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {"%8t .gblinit: block(0x20000)   {}"} else {"%8t .gblinit:   {} load > %1s%2s, run\0, _loadgblinitSeg, _gblinitpg"}} else {"%8t .gblinit: block(0x20000)   {}"})
    prop _dataString :: ("%8t .data: block(0x20000)  {}")
    prop _constString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {if 55 == 28 {"%8t .const:    {}"} else {"%8t GROUP {\n %8t .const: {} \n %8t .printf (COPY): {} \n%8t }"}} else {if ((55 == 54) || (55 == 28)) {if 55 == 28 {"%8t .const:   {} load > %1s PAGE %2s, run\0, _loadconstSeg, _pg"} else {"%8t GROUP {\n %8t .const: {} load > %1s PAGE %2s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg, _pg"}} else {if (55 == 55) {"%8t GROUP {\n %8t .const: {} load > %1s%2s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg, _constpg"} else {"%8t GROUP {\n %8t .const: {} load > %1s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg"}}}} else {if 55 == 28 {"%8t .const:    {}"} else {"%8t GROUP {\n %8t .const: {} \n %8t .printf (COPY): {} \n%8t }"}})
    prop _switchString :: (if (self.ENABLELOADSEG == 1) {if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {"%8t .switch:   {}"} else {"%8t .switch:   {} load > %1s%2s, run\0, _loadswitchSeg, _switchpg"}} else {"%8t .switch:    {}"})
    prop _sysmemString :: ("%8t .sysmem:  {}")
    prop _cioString :: ("%8t .cio:     {}")
    prop _memObjString :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (if ((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {"%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"} else {"%8t .sysdata: block(0x20000) {}"})
    prop _sysinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.INITSEG == MEM.LOADINITSEG) {"%8t .sysinit:   {}"} else {"%8t .sysinit:   {} load > %1s%2s, run\0, _loadinitSeg, _sysinitpg"}} else {"%8t .sysinit:    {}"})
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {"%8t .text:    {}"} else {"%8t .text:    {} load > %1s%2s, run\0, _loadtextSeg, _textpg"}} else {"%8t .text:    {}"})
    prop _frtString :: ("%8t frt:    {}")
    prop _biosString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {"%8t .bios:    {}"} else {"%8t .bios:    {} load > %1s%2s, run\0, _loadbiosSeg, _biospg"}} else {"%8t .bios:    {}"})
    prop _stackString :: (if (GBL.DSPTYPE == 62) {"%8t .stack: align = 0x8 {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 8;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"} else {if (GBL.DSPTYPE == 54) {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"} else {if (GBL.DSPTYPE == 55) {"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"} else {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"}}})
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: ("%0t}")
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop _biospg :: (if (MEM.LOADBIOSSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADBIOSSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADBIOSSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _sysinitpg :: (if (MEM.LOADINITSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADINITSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADINITSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _gblinitpg :: (if (MEM.LOADBIOSINITSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADBIOSINITSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADBIOSINITSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _trcdatapg :: (if (MEM.LOADTRCINITSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADTRCINITSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADTRCINITSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _textpg :: (if (MEM.LOADTEXTSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADTEXTSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADTEXTSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _switchpg :: (if (MEM.LOADSWITCHSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADSWITCHSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADSWITCHSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _cinitpg :: (if (MEM.LOADCINITSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADCINITSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADCINITSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _pinitpg :: (if (MEM.LOADPINITSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADPINITSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADPINITSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _constpg :: (if (MEM.LOADCONSTSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADCONSTSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADCONSTSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop AllocInst :: (if (self.iAllocHeap == 1) {"1\0, _instAllocDesc, _objMemSeg, _placement"} )
    prop _instAllocDesc :: (if self.INITSEG.iAllocHeap && self.REUSE && self.INITSEG == self {"%8t GROUP RUN_START(%0r$Bb), RUN_START(_%0r_baseb), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length) {%12t\n.sysinitgap {. += 0x%2x;}\n.sysinit: {%16t\n_%0r_base = _%0r_baseb / 2;%16t\n%0r$B = %0r$Bb / 2;%12t\n}%12t\n.%0r$heap: {%16t\n. += 0x%1x;%12t\n}%8t\n }\0, _heapsize, _sysinitgap, _heaplen"} else {"%8t .%0r$heap: RUN_START(%0r$Bb), RUN_START(_%0r_baseb), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length) {%12t\n . += 0x%1x;%12t\n %0r$B = %0r$Bb / 2;%12t\n _%0r_base = _%0r_baseb / 2;%8t\n } \0, _cmd55heapsize, _cmd55heaplen"})
    prop _objMemSeg :: self
    prop _placement :: 0x7fffff - 1
    prop _heapsize :: (self.iHeapSize)
    prop _heaplen :: (self.iHeapSize)
    prop _sysinitgap :: 2 * 1
    prop GenInstLink :: (if GBL.DSPTYPE == 62 {"%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"} else {if GBL.DSPTYPE == 55 {"PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"} else {"PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"}})
    prop localInit :: ($d = "ok", scan ($i; MEM) {if ($i.space == "code" && $i.iAllocHeap == 1) {$d = self.error("Code memory cannot have a heap")} }, if (self.SEGZERO.iAllocHeap == 1) {self.SEGZERO.iReqHeapCount++} else {$d = self.error("Segment for DSP/BIOS objects must be a memory segment with a heap")}, if (self.MALLOCSEG.iAllocHeap == 1) {self.MALLOCSEG.iReqHeapCount++} else {$d = self.error("Segment for malloc()/free() must be a memory segment with a heap")}, $d)
    prop _page :: (self.page)
    prop _origin :: (self.base)
    prop _len :: (self.len)
    prop maxObjs :: (32767)
    prop codeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {(($1.space == "code") || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 54 {($1.space == "code")} else {if GBL.DSPTYPE == 28 {($1.space == "code" || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 55 {(($1.space == "code") || ($1.space == "code/data"))} else {($1.space == "code/data")}}}}})
    prop dataMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 28 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {(($1.space == "code/data") && ($1 != MEM_NULL))}}}}})
    prop dataNullMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 54 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 28 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 55 {$1.space == "data" || $1.space == "code/data"} else {$1.space == "code/data"}}}}})
    prop dataCodeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 28 {($1.space == "code" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {$1.space == "code/data" && $1 != MEM_NULL}}}}})
    prop memWritable :: (self.iIsModifiable && self.iDelUser != "MEM")
    prop validate :: ($e = self.checkMemOverlap($1), if ($e == "ok") {$e = self.checkHeapSize($1)} , if ($e == "ok") {$e = self.checkHeapSeg($1)} , $e)
    prop checkHeapSeg :: ($e = "ok", if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {if (MEM.MALLOCSEG == MEM_NULL) {$e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")} , if (MEM.SEGZERO == MEM_NULL) {$e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")} } , $e)
    prop checkHeapSize :: ($e = "ok", if (MEM.NOHEAPS == 0) {if ($1.iAllocHeap && $1 != MEM_NULL) {if ($1.iHeapSize > $1.len) {$e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")} } } , $e)
    prop checkMemOverlap :: ($e = "ok", if ($1 != MEM_NULL && $1.iIsUsed == 1) {if ($1.len == 0) {$a = $1.base} else {$a = ($1.base + $1.len - 1)}, scan ($j; MEM) {if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 && (GBL.DSPTYPE == 62 || $1.space == $j.space)) {if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {$b = $j.base, if ($j.len == 0) {$c = $j.base} else {$c = ($j.base + $j.len - 1)}, if ($a >= $b && $1.base <= $c) {$e = ("MEM segment %s: overlaps with another segment or cache configuration."), break} } } }} , $e)
    prop _spaceEnum :: (self.ENUMSPACE)
    prop checkHeapId :: ($e = "ok", scan ($i; MEM) {if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {$e = self.error("This identifier label is already in use"), break} }, $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 6 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap :: = ($a = 0, scan ($i; MEM) {if ($i != MEM_NULL) {$a += $i.iAllocHeap} }, $a) { 
        prop NoGen :: 0
    }
    global REUSE :: = (if self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1 {self.SAVEREUSE} else {0}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reuse Startup Code Space"
        prop JSName :: "REUSECODESPACE"
        prop Visible :: 1
        prop Writable :: self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1
        prop NoGen :: 1
        prop Set :: (self.SAVEREUSE = $1, "ok")
    }
    global SAVEREUSE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    global doCheckOverlap :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MAPSELECT :: "Map 1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Map Mode"
        prop JSName :: "MAPMODE"
        prop Enum :: "Map 0,Map 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ARGSSIZE :: = if GBL.LARGEMODEL == 1 {16} else {8} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Argument Buffer Size"
        prop JSName :: "ARGSSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("The 'arguments' section must have at least 4 words.")} else {self.ARGSSIZE = $1 << 1, "ok"})
    }
    global ARGSSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Argument Buffer Section (.args)"
        prop JSName :: "ARGSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global BIOSSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "BIOS Code Section (.bios)"
        prop JSName :: "BIOSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: if GBL.DSPTYPE == 54 {0x01 | 0x02} else {0x02}
        prop Label :: "Stack Size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {self.STACKSIZE = ($1 & -2)} else {if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {self.STACKSIZE = ($1 & -4)} else {self.STACKSIZE = $1}}, "ok")
        prop PropSetOkUserMsg :: if (MEM.STACKSIZE < GlobalStatus.MinStackSize) {"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!"} else {"ok"}
    }
    global USERCMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User .cmd File For Compiler Sections"
        prop JSName :: "USERCOMMANDFILE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Stack Section (.stack)"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global SYSSTACKSIZE :: 256 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "System Stack Size (MAUs)"
        prop JSName :: "SYSSTACKSIZE"
        prop Visible :: if GBL.DSPTYPE == 55 {1} else {0}
        prop Writable :: 1
        prop NoGen :: 1
    }
    global SYSSTACKSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "System Stack Section (.sysstack)"
        prop JSName :: "SYSSTACKSEG"
        prop Visible :: if GBL.DSPTYPE == 55 {1} else {0}
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global ENABLELOADSEG :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
        prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - BIOS Code Section (.bios)"
        prop JSName :: "LOADBIOSSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global INITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Startup Code Section (.sysinit)"
        prop JSName :: "SYSINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - Startup Code Section (.sysinit)"
        prop JSName :: "LOADSYSINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "GBLINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "TRC Initial Value (.trcdata)"
        prop JSName :: "TRCDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "LOADGBLINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - TRC Initial Value (.trcdata)"
        prop JSName :: "LOADTRCDATASEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SYSDATASEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Kernel State (.sysdata)"
        prop JSName :: "SYSDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
        prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No Dynamic Memory Heaps"
        prop JSName :: "NOMEMORYHEAPS"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.SEGZERO.iReqHeapCount--, self.SEGZERO = MEM_NULL, self.MALLOCSEG.iReqHeapCount--, self.MALLOCSEG = MEM_NULL, TSK.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, scan ($i; MEM) {if ($i.iAllocHeap && $i != MEM_NULL) {$i.iAllocHeap = 0, $i.iHeapSize = 0} }} , self.NOHEAPS = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.NOHEAPS == 1) {"Currently specified heaps no longer valid"} else {"Please reconfigure heaps under individual mem segments"}
    }
    global SEGZERO :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For DSP/BIOS Objects"
        prop JSName :: "BIOSOBJSEG"
        prop Visible :: 1
        prop Writable :: MEM.NOHEAPS == 0
        prop NoGen :: 0
        prop Set :: (if (self.SEGZERO.iReqHeapCount > 0) {self.SEGZERO.iReqHeapCount--} , self.SEGZERO = $1, self.SEGZERO.iReqHeapCount++, "ok")
    }
    global MALLOCSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
        prop JSName :: "MALLOCSEG"
        prop Visible :: 1
        prop Writable :: (MEM.NOHEAPS == 0)
        prop NoGen :: 0
        prop Set :: (if (self.MALLOCSEG.iReqHeapCount > 0) {self.MALLOCSEG.iReqHeapCount--} , self.MALLOCSEG = $1, self.MALLOCSEG.iReqHeapCount++, "ok")
    }
    global LNKCMDFILE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TEXTSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Text Section (.text)"
        prop JSName :: "TEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Load Address - Text Section (.text)"
        prop JSName :: "LOADTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SWITCHSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Switch Jump Tables (.switch)"
        prop JSName :: "SWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Switch Jump Tables (.switch)"
        prop JSName :: "LOADSWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BSSSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.bss)"
        prop JSName :: "BSSSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global FARSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.far)"
        prop JSName :: "FARSEG"
        prop Visible :: if GBL.DSPTYPE == 62 {1} else {0}
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Data Initialization Section (.cinit)"
        prop JSName :: "CINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Data Initialization Section (.cinit)"
        prop JSName :: "LOADCINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global PINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "C Function Initialization Table (.pinit)"
        prop JSName :: "PINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADPINITSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - C Function Initialization Table (.pinit)"
        prop JSName :: "LOADPINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Constant Sections (.const, .printf)"
        prop JSName :: "CONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Load Address - Constant Sections (.const, .printf)"
        prop JSName :: "LOADCONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global DATASEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.data)"
        prop JSName :: "DATASEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.cio)"
        prop JSName :: "CIOSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
        prop Set :: (self.CIOSEG = $1, self.SYSMEMSEG = $1, "ok")
    }
    global SYSMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.sysmem)"
        prop JSName :: "SYSMEMSEG"
        prop Visible :: 0
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory (.hwi)"
        prop JSName :: "HWISEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.STUBMEMSEG = $1, HWI.STUBMEMSEG = $1, "ok")
    }
    global LOADSTUBMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - Function Stub Memory (.hwi)"
        prop JSName :: "LOADHWISEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global VECMEMSEG :: VECT { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "HWIVECSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.VECMEMSEG = $1, HWI.VECMEMSEG = $1, "ok")
    }
    global LOADVECMEMSEG :: VECT { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "LOADHWIVECSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop JSName :: "RTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.RTDXTEXTMEMSEG = $1, RTDX.TEXTMEMSEG = $1, "ok")
    }
    global LOADRTDXTEXTMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
        prop JSName :: "LOADRTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global ENUMSPACE :: = if GBL.DSPTYPE == 62 {"code,data,code/data,reserved"} else {if GBL.DSPTYPE == 54 {"code,data,io,other,reserved"} else {if GBL.DSPTYPE == 28 {"code,code/data,data,io,other,reserved"} else {if GBL.DSPTYPE == 55 {"code/data,code,data,io,reserved"} else {"code/data,io,reserved"}}}} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "ENUMSPACE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst base :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%06x"}
        prop Style :: 0x02
        prop Label :: "base"
        prop JSName :: "base"
        prop Visible :: 1
        prop Writable :: (self.iIsModifiable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", $a = self.base, self.base = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.base = $a} } , $e)
    }
    inst len :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x08
        prop Label :: "len"
        prop JSName :: "len"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 0
        prop Set :: ($e = "ok", $a = self.len, self.len = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.len = $a} } , "ok")
    }
    inst page :: = (if GBL.DSPTYPE == 62 {-1} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {0}}})} else {if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {3}}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iAllocHeap :: if MEM.NOHEAPS == 1 {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
        prop JSName :: "createHeap"
        prop Visible :: 1
        prop Writable :: (self.space == "data" || self.space == "code/data") && (MEM.NOHEAPS == 0) && self.memWritable
        prop NoGen :: 0
        prop Set :: ($a = "ok", if ($1 == 0 && self.iReqHeapCount > 0) {self.error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")} else {if ($1 == 0) {self.iUserHeapId = 0, self.iHeapId = @segment_name} , self.iAllocHeap = $1, MEM.gDirty = 1, $a})
    }
    inst iHeapSize :: 0x007FA0 / 2 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x02
        prop Label :: "heap size"
        prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (self.iHeapSize = $1, "ok")
        prop NoGen :: 1
    }
    inst iSegZero :: = MEM.SEGZERO
    inst iUserHeapId :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "enter a user defined heap identifier label"
        prop JSName :: "enableHeapLabel"
        prop Set :: (if ($1 == 0) {self.iHeapId = @segment_name} , self.iUserHeapId = $1, "ok")
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0)
        prop NoGen :: 1
    }
    inst iHeapId :: @segment_name { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "heap identifier label"
        prop JSName :: "heapLabel"
        prop Set :: ($e = self.checkHeapId($1), if ($e == "ok") {self.iHeapId = $1} , $e)
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0) && (self.iUserHeapId)
        prop Visible :: 1
        prop NoGen :: 0
    }
    inst iReqHeapCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst space :: (if GBL.DSPTYPE == 55 {"code/data"} else {"data"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: MEM._spaceEnum()
        prop JSName :: "space"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 != "data" && $1 != "code/data" && self.iAllocHeap == 1) {$e = self.error("Cannot select this space if a heap will be created")} else {$a = self.space, self.space = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.space = $a} } }, $e)
    }
    inst dynamicLoading :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reserved for dynamic loading"
        prop JSName :: "dynamicLoading"
        prop Visible :: GBL.ENABLEDLL
        prop Writable :: GBL.ENABLEDLL
        prop NoGen :: 1
    }
    inst iIsModifiable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 1
    param iHeapSize :: 16336
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _objMemDesc, _memSeg, _placement"} )
    prop _objMemDesc :: ("%8t .obj: block(0x20000) {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type BUF {
    isa ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (421)
    prop GlobalHelpTopic :: (321)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,      _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t.buf: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$data: block(0x20000) align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength")
    prop _objAlign :: self.align * 2
    prop _instMemSeg :: self.bufseg
    prop _buflength :: (self.postalignsize * self.bufcount) * 2
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"buf.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far BUF_Obj %0r;\n\0"} else {"extern BUF_Obj %0r;\n\0"})
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = ((7 + 3) * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = ((7 + 4) * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = ((7 + 3) * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (7 + 4)} , if (GBL.DSPTYPE == 28) {$a = (12 + 6)} , $a)
    prop dataSize :: ($d = 0, scan ($i; BUF) {if ($i.IsConfObj()) {$d += $i.len} , $d += BUF.objectSize}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Memory segment for buffer pool"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst bufcount :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer count"
        prop JSName :: "bufCount"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (self.bufcount = $1, self.postalignsize = (self.size + (self.align - 1)) & ~(self.align - 1), self.len = $1 * self.postalignsize, "ok")
    }
    inst size :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer size (MADUs)"
        prop JSName :: "size"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 4) {self.error("Size should be atleast 4 words")} else {self.size = $1, self.postalignsize = ($1 + (self.align - 1)) & ~(self.align - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst align :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer alignment(Power of 2)"
        prop JSName :: "align"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 2) {self.error("Alignment should be atleast 2 ")} else {self.align = $1, self.postalignsize = (self.size + ($1 - 1)) & ~($1 - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst len :: self.size { 
        prop Label :: "Buffer pool length (MADUs)"
        prop JSName :: "len"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst postalignsize :: self.size { 
        prop Label :: "Buffer size after alignment (MADUs)"
        prop JSName :: "postalignsize"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type POOL {
    isa Module
    prop Visible :: 1
    prop name :: "POOL"
    prop Label :: "POOL - Allocator Manager"
    prop IsConfMod :: self.USEPOOL
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop GlobalHelpTopic :: (324)
    prop InstanceHelpTopic :: (424)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "MEM,BUF"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEPOOL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Allocator Manager"
        prop JSName :: "ENABLEPOOL"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (202)
    prop GlobalHelpTopic :: (102)
    prop InstancePropertyPage :: ("{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}")
    prop objectSize :: ($a = (2 * 1), $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: block(0x20000), RUN_START(%1U_A_TABBEGb) {\n%8tCLK_F_gethtime = %5s;\n%8t%1U_A_TABBEG = %1U_A_TABBEGb / 2;\n %4S \n%4t} > %3s%6s\0, name, _objSize, _memSeg, _linkString, clkFxn, _memSegPg")
    prop GenLinkEpilogue :: ("%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TCR = CLK_TCR;\n_CLK_TDDR = CLK_TDDR;\n\0")
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no CLK objs */"}
    prop _memSeg :: CLK.OBJMEMSEG
    prop _memSegPg :: (if CLK.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if CLK.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if CLK.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})
    prop _objSize :: 2 * self.objectSize()
    prop clkFxn :: if (self.USETIMER == 1) {self.CLKFXN} else {@FXN_F_zero}
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (if (GBL.CALLBACKOBJ != CLK) {CLK.gGBLChain = GBL.CALLBACKOBJ, GBL.CALLBACKOBJ = CLK} )
    prop dataSize :: (self.objectSize() * (CLK.gNumOf + 1))
    prop localCanCreate :: (if self.USETIMER {"ok"} else {self.error("The CLK Manager must be enabled before inserting a CLK")})
    prop localCreate :: (CLK.HOOKFXN = @_CLK_dispRun, self.seizeHwi(self.WHICHHWI), "ok")
    prop localDelete :: (if (self.gNumOf == 1) {CLK.HOOKFXN = @FXN_F_nop, self.seizeHwi(self.WHICHHWI)} , "ok")
    prop adjustPrd :: 1
    prop seizeHwi :: (if ($1.client == "USER" && $1 == HWI_UNUSED) {self.error("Interrupt not mapped for selected timer.")} else {if ($1.client == "USER" && $1.function != @HWI_unused) {self.error("Interrupt mapped to selected timer is already in use.")} else {if ($1.client == "CSL") {self.error("Interrupt mapped to selected timer is already in use by CSL.")} else {$1.function = @_CLK_dispatch, $1.client = "CLK", $1.iUseDispatcher = 1, $1.iArg = 0, HWI.gDirty = 1, "ok"}}})
    prop releaseHwi :: ($1.function = @HWI_unused, $1.client = "USER", $1.iUseDispatcher = 0, $1.iArg = 0, HWI.gDirty = 1, "ok")
    prop seizeTimer :: (self.WHICHHWI = HWI_INT4, self.TIMERIMR = 0x00, self.TIMERIFR = 0x01, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, if ($1 == "Timer 0") {self.WHICHTIMER = "Timer 0", self.REGS = 0x1810, self.TIMERNUM = 0, self.INTBIT = 0, self.TIMER0FUNC = @_CLK_isr, self.TIMER0ARG = 1, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 1") {self.WHICHTIMER = "Timer 1", self.REGS = 0x1850, self.TIMERNUM = 1, self.INTBIT = 1, self.TIMER1FUNC = @_CLK_isr, self.TIMER1ARG = 2, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 2") {self.WHICHTIMER = "Timer 2", self.REGS = 0x1890, self.TIMERNUM = 2, self.INTBIT = 2, self.TIMER2FUNC = @_CLK_isr, self.TIMER2ARG = 4, self.setMicroseconds(self.MICROSECONDS)} }}, self.TIMERIMRMASK = 1 << (self.WHICHHWI.iId % 16), "ok")
    prop setMicroseconds :: ($e = 0x7fffffff, if ($1 > 0.1) {$d = $1 * GBL.MIPS / 2, self.TDDR = 0, self.PRDMULTFACTOR = 2, while ($d > $e) {$d = $d / 2, self.TDDR += 1, self.PRDMULTFACTOR *= 2}, self.PRD = int($d) - 1, self.MICROSECONDS = ((float((self.PRD)) + 1) * (self.PRDMULTFACTOR) / GBL.MIPS), if (self.CALLBACKOBJ != nil) {self.CALLBACKOBJ.call()} , if (self.TDDR > 12) {self.error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")} else {"ok"}} else {self.error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")})
    prop call :: ($a = ((float((CLK.PRD)) + 1) * (CLK.PRDMULTFACTOR) / GBL.MIPS), $b = CLK.MICROSECONDS, $e = "ok", if (($e = self.setMicroseconds(CLK.MICROSECONDS)) == "ok") {if (CLK.gGBLChain != nil) {$e = CLK.gGBLChain.call()} , if ($e != "ok") {self.setMicroseconds($b), self.error($e)} else {"ok"}} else {$e})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gGBLChain :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global IMR0TINTMASK :: 16 { 
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global IMR1TINTMASK :: 0 { 
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global WHICHHWI :: HWI_INT4 { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop Label :: "CPU Interrupt"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global INTBIT :: = (if self.WHICHTIMER == "Timer 0" {0} else {if self.WHICHTIMER == "Timer 1" {1} else {2}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global TIMERIMRMASK :: = (1 << (self.WHICHHWI.iId % 16)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global WHICHTIMER :: "Timer 0" { 
        prop Label :: "Timer Selection"
        prop JSName :: "TIMERSELECT"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1,Timer 2"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (self.WHICHTIMER != $1) {if (self.USETIMER == 0) {$e = "ok"} else {if ($1 == "Timer 0") {$a = Timer_0.iHwi} else {if ($1 == "Timer 1") {$a = Timer_1.iHwi} else {$a = Timer_2.iHwi}}, $e = self.seizeHwi($a)}, if ($e == "ok") {if (self.WHICHTIMER == "Timer 0") {self.TIMER0FUNC = @FXN_F_nop, self.TIMER0ARG = 0} else {if (self.WHICHTIMER == "Timer 1") {self.TIMER1FUNC = @FXN_F_nop, self.TIMER1ARG = 0} else {self.TIMER2FUNC = @FXN_F_nop, self.TIMER2ARG = 0}}, self.releaseHwi(self.WHICHHWI), self.WHICHTIMER = $1, if ($1 == "Timer 0") {self.seizeTimer("Timer 0")} else {if ($1 == "Timer 1") {self.seizeTimer("Timer 1")} else {self.seizeTimer("Timer 2")}}, self.HOOKFXN = if self.gNumOf > 0 {@_CLK_dispRun} else {@FXN_F_nop}, self.seizeHwi(self.WHICHHWI)} , $e} )
    }
    global TIMER0FUNC :: = if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 0") {@_CLK_isr} else {@FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 0 function"
        prop JSName :: "TIMER0FUNC"
        prop Visible :: 1
        prop Writable :: if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 0") {0} else {1}
        prop NoGen :: 0
        prop TabName :: "Timer 0"
        prop Set :: (if ($1 != @FXN_F_nop) {self.TIMER0FUNC = $1, self.seizeHwi(self.WHICHHWI)} , "ok")
    }
    global TIMER0ARG :: = if self.WHICHTIMER == "Timer 0" {1} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 0 argument"
        prop JSName :: "TIMER0ARG"
        prop Visible :: 1
        prop Writable :: if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 0") {0} else {1}
        prop NoGen :: 0
        prop TabName :: "Timer 0"
    }
    global TIMER1FUNC :: = if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 1") {@_CLK_isr} else {@FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 1 function"
        prop JSName :: "TIMER1FUNC"
        prop Visible :: 1
        prop Writable :: if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 1") {0} else {1}
        prop NoGen :: 0
        prop TabName :: "Timer 1"
        prop Set :: (if ($1 != @FXN_F_nop) {self.TIMER1FUNC = $1, self.seizeHwi(self.WHICHHWI)} , "ok")
    }
    global TIMER1ARG :: = if self.WHICHTIMER == "Timer 1" {2} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 1 argument"
        prop JSName :: "TIMER1ARG"
        prop Visible :: 1
        prop Writable :: if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 1") {0} else {1}
        prop NoGen :: 0
        prop TabName :: "Timer 1"
    }
    global TIMER2FUNC :: = if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 2") {@_CLK_isr} else {@FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 2 function"
        prop JSName :: "TIMER2FUNC"
        prop Visible :: 1
        prop Writable :: if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 2") {0} else {1}
        prop NoGen :: 0
        prop TabName :: "Timer 2"
        prop Set :: (if ($1 != @FXN_F_nop) {self.TIMER2FUNC = $1, self.seizeHwi(self.WHICHHWI)} , "ok")
    }
    global TIMER2ARG :: = if self.WHICHTIMER == "Timer 2" {4} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 2 argument"
        prop JSName :: "TIMER2ARG"
        prop Visible :: 1
        prop Writable :: if (self.USETIMER == 1) && (self.WHICHTIMER == "Timer 2") {0} else {1}
        prop NoGen :: 0
        prop TabName :: "Timer 2"
    }
    global REGS :: 6160 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERIMR :: 69 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERIFR :: 70 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERNUM :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop NoGen :: 0
    }
    global USETIMER :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable CLK Manager"
        prop JSName :: "ENABLECLK"
        prop Visible :: 1
        prop Writable :: if self.gNumOf > 0 {0} else {1}
        prop NoGen :: 0
        prop Set :: (if ($1 == 1 && self.USETIMER == 0) {self.WHICHHWI = Timer_0.iHwi, self.WHICHTIMER = "Timer 0", if (($e = self.seizeHwi(self.WHICHHWI)) != "ok") {self.WHICHHWI = Timer_1.iHwi, self.WHICHTIMER = "Timer 1", if (($e = self.seizeHwi(self.WHICHHWI)) != "ok") {self.WHICHHWI = Timer_2.iHwi, self.WHICHTIMER = "Timer 2", if (($e = self.seizeHwi(self.WHICHHWI)) != "ok") {$e} } } , if ($e == "ok") {self.USETIMER = 1, self.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@_CLK_getltime}, self.HOOKFXN = if self.gNumOf > 0 {@_CLK_dispRun} else {@FXN_F_nop}, self.seizeHwi(self.WHICHHWI), self.seizeTimer(".WHICHTIMER"), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, GlobalStatus.gDirty = 1, self.error("Current stack size inadequate to enable CLK")} else {if (GBL.ENABLEINST == 1) {IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE} , "ok"}} , $e} else {if ($1 == 0 && self.USETIMER == 1) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, if (GBL.ENABLEINST == 1) {IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0} , "ok"} else {"ok"}})
    }
    global HIRES :: = 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use high resolution time for internal timings"
        prop JSName :: "HIRESTIME"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (CLK.USETIMER) {CLK.HIRES = $1, if (CLK.USETIMER) {CLK.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@_CLK_getltime}} , "ok"} else {self.error("CLK Manager must be enabled in order to get high resolution timings.")})
    }
    global INSTRPERCLK :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "Microseconds/Int"
        prop JSName :: "MICROSECONDS"
        prop Set :: (self.setMicroseconds($1))
        prop Visible :: 1
        prop Writable :: if ((CLK.PROGTIMREGS != 0) | (self.USETIMER == 0)) {0} else {1}
        prop NoGen :: 1
    }
    global MICROSECS :: = int(round(self.MICROSECONDS)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PROGTIMREGS :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Directly configure on-chip timer registers"
        prop JSName :: "CONFIGURETIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global FIXTDDR :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Fix TDDR"
        prop JSName :: "FIXTDDR"
        prop Visible :: 0
        prop Writable :: CLK.PROGTIMREGS
        prop NoGen :: 1
    }
    global TDDR :: = 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12"
        prop Label :: "Prescale Divider"
        prop JSName :: "PRESCALE"
        prop Set :: (CLK.TDDR = $1, if (self.TDDR == 0) {self.PRDMULTFACTOR = 2} , if (self.TDDR == 1) {self.PRDMULTFACTOR = 4} , if (self.TDDR == 2) {self.PRDMULTFACTOR = 8} , if (self.TDDR == 3) {self.PRDMULTFACTOR = 16} , if (self.TDDR == 4) {self.PRDMULTFACTOR = 32} , if (self.TDDR == 5) {self.PRDMULTFACTOR = 64} , if (self.TDDR == 6) {self.PRDMULTFACTOR = 128} , if (self.TDDR == 7) {self.PRDMULTFACTOR = 256} , if (self.TDDR == 8) {self.PRDMULTFACTOR = 512} , if (self.TDDR == 9) {self.PRDMULTFACTOR = 1024} , if (self.TDDR == 10) {self.PRDMULTFACTOR = 2048} , if (self.TDDR == 11) {self.PRDMULTFACTOR = 4096} , if (self.TDDR == 12) {self.PRDMULTFACTOR = 8192} , if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , CLK.MICROSECONDS = ((float((CLK.PRD)) + 1) * ((CLK.PRDMULTFACTOR)) / GBL.MIPS), "ok")
        prop Visible :: 1
        prop Writable :: CLK.PROGTIMREGS
        prop NoGen :: 0
    }
    global TDDRHIGH :: = ((self.TDDR & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRDMULTFACTOR :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRD :: = (int(round((1000.0 * (GBL.MIPS) / CLK.PRDMULTFACTOR))) - CLK.adjustPrd) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: "Period Register"
        prop JSName :: "PRD"
        prop Set :: (CLK.PRD = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + 1) * ((CLK.PRDMULTFACTOR)) / GBL.MIPS), self.COUNTSPMS = (int(round(GBL.MIPS * 1000 / (CLK.PRDMULTFACTOR)))), self.COUNTSPMSHIGH = ((self.COUNTSPMS & 0xffff0000) >> 16), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok")
        prop Visible :: 1
        prop Writable :: if ((self.PROGTIMREGS) && (self.USETIMER)) {1} else {0}
        prop NoGen :: 0
    }
    global PRDHIGH :: = ((self.PRD & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global COUNTSPMS :: = int(round(GBL.MIPS * 1000.0 / (CLK.PRDMULTFACTOR))) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
    }
    global COUNTSPMSHIGH :: = ((self.COUNTSPMS & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global INSTRUCTIONS :: = (1.0 * (float(CLK.PRD) + 1) * (CLK.PRDMULTFACTOR)) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.0f"
        prop Label :: "Instructions/Int"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TIMEFXN :: = CLK.clkFxn() { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HOOKFXN :: @_CLK_dispRun { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CLKFXN :: = if (CLK.PRD == 0xfffffffff) {@_CLK_getfhtime} else {@_CLK_getshtime} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: PRD { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALDIV :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALMULT :: = self.PRDMULTFACTOR * 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEDIV :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEMULT :: = self.PRDMULTFACTOR { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEDIV :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEMULT :: = self.PRDMULTFACTOR * (self.PRD + 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEPERLTIME :: = self.PRD + CLK.adjustPrd { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (210)
    prop GlobalHelpTopic :: (110)
    prop InstancePropertyPage :: ("{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: ("%g ticks")
    prop STSGetSumFmt :: (PRD.STSGetMaxFmt())
    prop STSGetAvgFmt :: ("%.2f ticks")
    prop GetPeriod :: self.period
    prop IsOneShot :: if self.mode == "one-shot" {1} else {0}
    prop objectSize :: (if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (9 * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (12 * 1)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (12 * 1)} , if (GBL.DSPTYPE == 62) {$a = (8 * 1)} , $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.prd: block(0x20000) RUN_START(PRD_A_TABBEGb), RUN_END(PRD_A_TABENDb) {%8t\nPRD_A_TABBEG = PRD_A_TABBEGb / 2;%8t\nPRD_A_TABEND = PRD_A_TABENDb / 2;%4t\n} > %1s%2s\0, memSeg, pageString")
    prop GenLinkEpilogue :: ("%0t}\nPRD_A_TABLEN = %1d;\n\0, numInst")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if PRD.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if PRD.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if PRD.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {self.objectSize() * 2} else {self.objectSize()}
    prop numInst :: (PRD.gNumOf)
    prop dataSize :: (self.objectSize() * PRD.gNumOf)
    prop localInit :: (if (CLK.CALLBACKOBJ != nil) {self.error("PRD initialization failure")} , CLK.CALLBACKOBJ = PRD, if (PRD.USECLK && PRD_clock.iIsUsed == 0) {PRD_clock.Create("PRD")} , if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} else {PRD_clock.function = @PRD_F_tick}} )
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error(" System Stack Size too small")} else {self.myCreate("can")})
    prop localCreate :: (STS.gNumEmbed += 1, if (($a = self.myCreate("do")) == "ok") {if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {PRD_clock.function = @PRD_F_tick} } } , $a)
    prop localCanDelete :: (self.myDelete("can"))
    prop localDelete :: (STS.gNumEmbed -= 1, if (($a = self.myDelete("do")) == "ok") {if (self.gNumOf == 1) {if (PRD_clock.iIsUsed == 1) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} } } , $a)
    prop maxObjs :: (32767)
    prop myCreate :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (PRD_swi.iIsUsed) {"ok"} else {if (SWI.CanCreate() == "ok") {if ($1 == "do") {if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {PRD_swi.pri = 1} , PRD_swi.Create("PRD")} else {"ok"}} else {self.error("Can't create an SWI for PRD (try deleting a SWI)")}})
    prop myDelete :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (self.gNumOf == 1) {if ($1 == "do") {PRD_swi.Delete("PRD")} else {"ok"}} else {"ok"})
    prop call :: (if (CLK.USETIMER != 0) {PRD.MICROSECONDS = CLK.MICROSECONDS} , PRD.CALLBACKOBJ.call())
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"prd.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PRD_Obj %0r;\n\0"} else {"extern PRD_Obj %0r;\n\0"})
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop DEFAULT_THOOKFXN :: @KNL_tick_stub
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USECLK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use CLK Manager to drive PRD"
        prop JSName :: "USECLK"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 1 && self.USECLK == 0) {if (CLK.USETIMER == 0) {self.error("In order to drive periodic functions, the CLK Manager must be enabled")} else {self.USECLK = 1, self.MICROSECONDS = CLK.MICROSECONDS, CLK.CALLBACKOBJ = PRD, PRD_clock.Create("PRD"), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD"), self.error("Current Stack size inadequate to enable this option")} else {"ok"}}} else {if ($1 == 0 && self.USECLK == 1) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD")} , "ok"})
        prop NoGen :: 1
    }
    global MICROSECONDS :: = CLK.MICROSECONDS { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Label :: "Microseconds/Tick"
        prop JSName :: "MICROSECONDS"
        prop Visible :: 1
        prop Writable :: self.USECLK == 0
        prop NoGen :: 1
    }
    global SCALAR :: = ($d = 2, $f = 0, while ($d <= 0x4000 && $f == 0) {scan ($i; PRD) {if ((($i.period / $d) * $d != $i.period)) || ($i.mode == "one-shot") {$f = 1} }, if ($f == 0) {$d = 2 * $d} }, $d / 2) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global THOOKFXN :: @KNL_tick_stub { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "System Tick Hook Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALLBACKOBJ :: STS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst period :: 0x7fff { 
        prop Label :: "period (ticks)"
        prop JSName :: "period"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if (($1 > 0) && ($1 < 0x8000)) {self.period = $1, self.gDirty = 1, "ok"} else {self.error("Periodic function periods must be greater than 0 and less than 0x8000")})
    }
    inst mode :: "continuous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "continuous,one-shot"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst milliseconds :: = ((self.period * PRD.MICROSECONDS) / 1000.0) { 
        prop Label :: "period (ms)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    inst filter :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: "%g ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: "%g ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: "%.2f ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst unittype :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

object PRD_swi :: SWI {
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted when all PRD objects are deleted"
    param function :: @PRD_F_swi
    param pri :: 1
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

object PRD_clock :: CLK {
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    param function :: @PRD_F_tick
    param Order :: 0
    param iPri :: 0
}

type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: self.USERTDX
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (113)
    prop InstanceHelpTopic :: (213)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop AllocType :: (if self.USERTDX {"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"} else {""})
    prop _rtdxDataAllocDesc :: (" .%1L_data: block(0x20000){} \0, name")
    prop _rtdxTextAllocDesc :: (if (MEM.ENABLELOADSEG == 1) {if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {" .%1L_text: {} \0, name"} else {" .%1L_text: {} load > %2s%3s, run \0, name, _loadRtdxTextMemSeg, _rtdx_textpg"}} else {" .%1L_text: {} \0, name"})
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop _rtdx_textpg :: (if (MEM.LOADRTDXTEXTMEMSEG.space() == "code/data") {" PAGE 0"} else {if (MEM.LOADRTDXTEXTMEMSEG.space() == "code") {" PAGE 1"} else {if (MEM.LOADRTDXTEXTMEMSEG.space() == "data") {" PAGE 2"} else {" PAGE 3"}}})
    prop GenLinkPrologue :: (if self.USERTDX {"_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"} else {""})
    prop _interruptMask :: RTDX.MASK
    prop cGen :: 1
    prop noObjectAlias :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"rtdx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {if (self.iChannelMode == "output") {"extern far RTDX_outputChannel %0r;\n\0"} else {"extern far RTDX_inputChannel %0r;\n\0"}} else {if (self.iChannelMode == "output") {"extern RTDX_outputChannel %0r;\n\0"} else {"extern RTDX_inputChannel %0r;\n\0"}})
    prop cGenCInst :: (if (self.iChannelMode == "output") {"RTDX_CreateOutputChannel(%0r);\n\0"} else {"RTDX_CreateInputChannel(%0r);\n\0"})
    prop dataSize :: ($d = 0, if (self.USERTDX) {$d = RTDX.BUFMEMSIZE} else {$d = 0}, scan ($a; RTDX) {if ($a.iChannelMode == "output") {$d += 1} else {$d += 3}}, $d)
    prop localCanCreate :: ($e = "ok", if (RTDX.USERTDX != 1) {$e = self.error("RTDX manager not enabled")} , $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USERTDX :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Data Exchange (RTDX)"
        prop JSName :: "ENABLERTDX"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {if (HST.LNKTYPE == "RTDX") {self.error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX")} else {if (self.gNumOf > 0) {self.error("Cannot disable RTDX until all RTDX objects are deleted.")} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"}}} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"})
    }
    global USERTEXECUTION :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Execution Control"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "JTAG,Simulator"
        prop Label :: "RTDX Mode"
        prop JSName :: "MODE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (self.RTDXTYPE = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok")
    }
    global DATAMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "RTDX Data Segment (.rtdx_data)"
        prop JSName :: "RTDXDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global BUFMEMSIZE :: = (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "RTDX Buffer Size (MAUs)"
        prop JSName :: "BUFSIZE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (if (HST.RTDX == 0) {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, "ok"} else {if ($1 < (HST.MAXFRAMESET + 3) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {self.error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 3) * (MAUs per word)")} else {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, if (HST.LNKTYPE == "RTDX") {HST.MAXFRAMEALLOWED = (self.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"} else {"ok"}}})
    }
    global TEXTMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Label :: "RTDX Interrupt Mask"
        prop JSName :: "INTERRUPTMASK"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.MASK = $1, "ok")
    }
    global CALLBACKOBJ :: HWI { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iChannelMode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Channel Mode"
        prop JSName :: "channelMode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.iChannelMode = $1, "ok")
    }
}

type HST {
    isa ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "HWI,GIO"
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (104)
    prop InstanceHelpTopic :: (204)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop dataSize :: ($b = 0, scan ($i; HST) {if ($i.IsConfObj()) {$b += ((6) + $i.framesize) * $i.numframes + PIP.OBJSIZE + self.objectSize()} }, $b)
    prop InstancePropertyPage :: ("{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: (PIP.gNumEmbed += 1, if (self.gNumOf == 0) {(LNK_dataPump.Create("HST"))} , "ok")
    prop localDelete :: (PIP.gNumEmbed -= 1, $b = 0, scan ($i; HST) {if ($i != self) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } } }, self.MAXFRAMESET = $b, if (self.gNumOf == 1) {(LNK_dataPump.Delete("HST"))} , "ok")
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, 	      _dsmAllocDesc, _dsmMemSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name")
    prop objectSize :: (if (GBL.DSPTYPE == 28) {$a = (14 * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (12 * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (12 * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 * 1)} , if (GBL.DSPTYPE == 54 || GBL.DSPTYPE == 62) {$a = (7 * 1)} , $a)
    prop _dsmAllocDesc :: ("%8t .dsm: block(0x20000) {}")
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: ("/* %0s buffer */\n.hst%2d: block(0x20000) %3S\0, name, _objId, _alignString, _objAlign")
    prop _alignString :: if self.bufalign > 1 {"align = 0x%4x {}"} else {""}
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"hst.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far HST_Obj %0r;\n\0"} else {"extern HST_Obj %0r;\n\0"})
    prop modifiable :: ((if self.iDelUser == "USER" {1} else {0}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LNKTYPE :: "RTDX" { 
        prop Label :: "Host Link Type"
        prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 == "RTDX") {if (RTDX.USERTDX == 0) {self.error("RTDX module must be enabled before it can be used by HST")} else {if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < self.MAXFRAMESET) {self.error("RTDX buffer size too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"}}}} else {if ($1 == "Shared Memory") {if ((self.DSMMEMSIZE / 4) < self.MAXFRAMESET) {self.error("Shared memory buffer too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"}}} else {if ($1 == "BIOSLINK") {if (GIO.USEGIO == 0) {self.error("GIO must be enabled")} else {self.LNKTYPE = $1, "ok"}} else {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, "ok"}}})
    }
    global RTDX :: = if self.LNKTYPE == "RTDX" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM :: = if self.LNKTYPE == "Shared Memory" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 :: = if self.LNKTYPE == "EVM54" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE :: = if self.LNKTYPE == "NONE" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global BIOSLINK :: = if self.LNKTYPE == "BIOSLINK" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use DSP/BIOS LINK for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET :: 64 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED :: 255 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
    }
    global DSMMEMSIZE :: = 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
        prop Set :: (if ($1 < HST.MAXFRAMESET * 4) {self.error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")} else {self.DSMMEMSIZE = $1, GlobalStatus.gDirty = 1, if (self.LNKTYPE == "Shared Memory") {self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {"ok"}})
    }
    global CHNLDRVNAME :: "default" { 
        prop Label :: "Host Side Channel Driver Name"
        prop JSName :: "CHNLDRVNAME"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global BIOSLINKDEVICE :: "undefined" { 
        prop Label :: "DSP/BIOS LINK Device Name"
        prop JSName :: "BIOSLINKDEVICE"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.BIOSLINK
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst mode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "mode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst bufalign :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("Alignment must be greater than or equal to 4")} else {if (($1 % 2) != 0) {self.error("Alignment must be a power of 2")} else {$i = $1, while ((($i % 2) == 0) && ($i != 2)) {$i = $i / 2}, if (($i % 2) != 0) {self.error("Alignment must be a power of 2")} else {self.bufalign = $1, "ok"}}})
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {if (($1 > self.MAXFRAMEALLOWED) && ((self.RTDX == 1) || (self.DSM == 1))) {if (self.RTDX == 1) {self.error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 3")} else {self.error("size (in words) is limited to: shared memory frame size (in MAUs)/4")}} else {self.framesize = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, GlobalStatus.gDirty = 1, "ok"}})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Channels must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst biosLinkChnlNbr :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP/BIOS LINK channel number[0..15]"
        prop JSName :: "biosLinkChnlNbr"
        prop Visible :: 1
        prop Writable :: self.BIOSLINK
        prop NoGen :: 0
        prop Set :: (if ($1 < 0 || $1 > 15) {self.error("BiosLink channel number must be [0..15]"), "error"} else {$b = 1, scan ($i; HST) {if ($i.IsConfObj()) {if ($i != self && $i.biosLinkChnlNbr == $1) {$b = 0, self.error("BiosLink channel number conflict")} } }, if ($b == 1) {GlobalStatus.gDirty = 1, self.biosLinkChnlNbr = $1, "ok"} else {"error"}})
    }
    inst stsflg :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "statistics"
        prop JSName :: "statistics"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst lnk :: = if self.RTDX {"RTDX"} else {"NOTRTDX"} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "link type"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Make this channel available for a new DHL device"
        prop JSName :: "availableForDHL"
        prop Set :: (if (($1 == 0) && (self.iDHLAvailable == 1)) {DHL.gChannelsAvailable--} else {if (($1 == 1) && (self.iDHLAvailable == 0)) {DHL.gChannelsAvailable++} }, self.iDHLAvailable = $1, "ok")
        prop Writable :: self.modifiable()
        prop Visible :: 1
        prop NoGen :: 1
    }
    inst bufFrameAlign :: = self.bufalign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object LNK_dataPump :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @LNK_F_dataPump
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_dispatcher :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @RTA_F_dispatch
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_fromHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "input"
    param bufseg :: DARAM
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 8
    param numframes :: 1
    param biosLinkChnlNbr :: 12
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

object RTA_toHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "output"
    param bufseg :: DARAM
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 64
    param numframes :: 1
    param biosLinkChnlNbr :: 13
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

type HWI {
    isa ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (205)
    prop GlobalHelpTopic :: (105)
    prop dataSize :: (0 * HWI.gNumOf)
    prop localCanCreate :: (self.error("New hardware interrupt objects cannot be created"))
    prop InstancePropertyPage :: ("{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "GBL,OBJ,BUF,CLK,IDL,LCK,LOG,MBX,MEM,PIP,POOL,PRD,QUE,RTDX,SEM,STS,SYS"
    prop AllocType :: ("3\0,   _stubsAllocDesc,        _memSeg,        _placement,
                _vectAllocDesc,         _vecSeg,        _minplace,
                _dispAllocDesc,         _dispSeg,       _minplace ")
    prop _dispAllocDesc :: ("%8t .hwi_disp_sec:  block(0x20000) {}")
    prop _stubsAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {"%8t .%1L:  {%8t\n%2S\n%8t} load > %3s%4s, run\0, name, _linkString, _loadstubSeg, _loadstubSegPg"} else {"%8t .%1L:  {%8t\n%2S\n%8t} \0, name, _linkString"})
    prop _vectAllocDesc :: (if (MEM.ENABLELOADSEG) {if (HWI.VECMEMSEG == MEM.LOADVECMEMSEG) {"%8t .%1L_vec: align = 0x100 {%12t\n (.hwi_vec)%8t\n } RUN_START(%1U_A_VECS), \0 , name, name"} else {"%8t .%1L_vec: align = 0x100 {%12t\n (.hwi_vec)%8t\n } RUN_START(%1U_A_VECS), load > %3s%4s, run\0, name, name, _loadvecSeg, _loadvecSegPg"}} else {"%8t .%1L_vec:  align = 0x100 {%12t\n *(.hwi_vec)%8t\n } RUN_START(%1U_A_VECS), \0 , name, name"})
    prop _placement :: (0x7fffff / 2)
    prop _minplace :: 0
    prop localInit :: (if (RTDX.CALLBACKOBJ != nil) {self.error("HWI initialization failure.")} , RTDX.CALLBACKOBJ = HWI)
    prop call :: (if (RTDX.USERTDX == 0) {HWI_DLOG.function = @HWI_unused, HWI_DLOG.iUseDispatcher = 0, if (HWI_RTOS.function == @_RTDX_H2TPoll) {HWI_RTOS.function = @HWI_unused, HWI_RTOS.iUseDispatcher = 0} } else {HWI_DLOG.function = @_RTDX_Poll, HWI_DLOG.iUseDispatcher = 1, HWI_RTOS.function = @_RTDX_H2TPoll, HWI_RTOS.iUseDispatcher = 1})
    prop _loadstubSegPg :: (if (MEM.LOADSTUBMEMSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADSTUBMEMSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADSTUBMEMSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop _loadvecSegPg :: (if (MEM.LOADVECMEMSEG.space() == "code") {" PAGE 0"} else {if (MEM.LOADVECMEMSEG.space() == "data") {" PAGE 1"} else {if (MEM.LOADVECMEMSEG.space() == "io") {" PAGE 2"} else {" PAGE 0"}}})
    prop GenLinkPrologue :: (if CLK.TIMERNUM == 0 {"HWI_TINT = HWI_INT4;\n_HWI_TINT = HWI_TINT;"} else {"HWI_TINT = HWI_INT22;\n_HWI_TINT = HWI_TINT;"})
    prop _dispSeg :: MEM.BSSSEG
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: ($b = 0, scan ($a; HWI) {if ($a.monitor != "Nothing") {$b = 1} }, if ($b == 1) {"*(.hwi)"} else {"/* no HWI stubs are necessary */"})
    prop name2addr :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "xsp", "ac0l", "ac0h", "ac0g", "ac1l", "ac1h", "ac1g", "ac2l", "ac2h", "ac2g", "ac3l", "ac3h", "ac3g", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67", "bsac", "trn1", "brc1", "csr", "rptc"}) {if ($b == nil) {if ($a == $1) {$b = {0, 0, 0x18, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x20, 0x21, 0x22, 0x23, 0x4c, 0, 0x2, 0x3, 0x4b, 0x4, 0xf, 0x19, 0x1a, 0x2e, 0x27, 0x2b, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3b, 0x44}[$i]} , $i++} }, if ($b == nil) {$b = 0} , $b)
    prop name2type :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "xsp", "ac0l", "ac0h", "ac0g", "ac1l", "ac1h", "ac1g", "ac2l", "ac2h", "ac2g", "ac3l", "ac3h", "ac3g", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67", "bsac", "trn1", "brc1", "csr", "rptc"}) {if ($b == nil) {if ($a == $1) {if ($i < 5) {$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]} } , $i++} }, if ($b == nil) {$b = "unsigned"} , $b)
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: -1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 32 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STUBMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ZEROTAB :: = self.VECMEMSEG.base == 0xffff00 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    global VECMEMSEG :: VECT { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: if GBL.DSPTYPE == 55 {($1.space != "data")} else {($1.space == "code")}
    }
    global STACKMODEL :: "USE_RETA" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C54X_STK,USE_RETA,NO_RETA"
        prop Label :: "Stack mode (See help. Does not automatically take effect without proper reset!)"
        prop JSName :: "STACKMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @HWI_unused { 
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if ((self.function == @RESERVED) || (self.client != "USER")) {0} else {1}
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (self.function = $1, GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTSObj :: HWI_RESETSTS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst monitor :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,xsp,ac0l,ac0h,ac0g,ac1l,ac1h,ac1g,ac2l,ac2h,ac2g,ac3l,ac3h,ac3g,xar0,xar1,xar2,xar3,xar4,xar5,xar6,xar7,t0,t1,t2,t3,xssp,tim,st0_55,st1_55,st2_55,st3_55,trn0,bk03,brc0,xdp,xcdp,dph,pdp,bk47,bkc,bsa01,bsa23,bsa45,bsa67,bsac,trn1,brc1,csr,rptc"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((self.function != @HWI_unused && self.function != @RESERVED) && (self.iId != 0))
        prop NoGen :: 0
        prop Set :: (if ($1 != self.monitor) {$e = "ok", if ($1 == "Nothing") {if (($e = self.iSTSObj.Delete("HWI")) == "ok") {self.monitor = "Nothing", self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)} } else {if (self.iSTSObj.iIsUsed || ($e = self.iSTSObj.Create("HWI")) == "ok") {self.monitor = $1, if (self.monitor == "Data Value") {self.addr = self.saveAddr, self.dataType = self.saveType} else {self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)}} else {self.monitor = "Nothing"}}, $e} else {"ok"})
    }
    inst saveAddr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst saveType :: "signed" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst addr :: 0 { 
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Data Value" {1} else {0})
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Set :: (self.addr = $1, self.saveAddr = $1, "ok")
    }
    inst dataType :: "signed" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (if (self.monitor != "Nothing") {self.dataType = $1, self.saveType = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst operation :: "STS_add(*addr)" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (if (self.monitor != "Nothing") {self.operation = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst client :: "USER" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: if (self.client == "USER") {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if (($1 == 1) && (self == HWI_NMI)) {self.error("HWI dispatcher can't be used for  NMI")} else {if (self.function == @CLK_F_isr) {self.error("This HWI is being used by the system and cannot be modified")} else {self.iUseDispatcher = $1, "ok"}})
    }
    inst iArg :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.client == "USER")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (self.iArg = $1, "ok")
    }
    inst iIer0Mask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER0"
        prop JSName :: "interruptMask0"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.Ier0Mask = 0xffff} else {if ($1 == "self") {if (self.iId < 16) {self.Ier0Mask = (1 << self.iId)} else {self.warning("This Interrupt is NOT maskable via IER0").Ier0Mask = 0}} else {if ($1 == "none") {self.Ier0Mask = 0} }}, self.iIer0Mask = $1, "ok")
    }
    inst Ier0Mask :: if (self.iId < 16) {(1 << self.iId)} else {0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER0"
        prop JSName :: "interruptBitMask0"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIer0Mask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.Ier0Mask = $1, "ok"})
    }
    inst iIer1Mask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER1"
        prop JSName :: "interruptMask1"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.Ier1Mask = 0xffff} else {if ($1 == "self") {if ((self.iId < 16) || (self.iId > 32)) {self.warning("This Interrupt is NOT maskable via IER1").Ier1Mask = 0} else {self.Ier1Mask = (1 << (self.iId - 16))}} else {if ($1 == "none") {self.Ier1Mask = 0} }}, self.iIer1Mask = $1, "ok")
    }
    inst Ier1Mask :: if (self.iId > 15) {if (self.iId < 32) {(1 << (self.iId - 16))} else {0}} else {0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER1"
        prop JSName :: "interruptBitMask1"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIer1Mask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.Ier1Mask = $1, "ok"})
    }
}

object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_c_int00
    param iSTSObj :: HWI_RESET_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 1
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_NMI_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 2
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT2_STS :: STS {
    param iComment :: "provides statistics for the INT2 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT2 :: HWI {
    param iComment :: "defines the INT2 Interrupt"
    param iIsUsed :: 1
    param iId :: 2
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT2_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 4
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT3_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT3 :: HWI {
    param iComment :: "defines the INT3 Interrupt"
    param iIsUsed :: 1
    param iId :: 3
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT3_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 8
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iIsUsed :: 1
    param iId :: 4
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_CLK_dispatch
    param iSTSObj :: HWI_INT4_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "CLK"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 16
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iIsUsed :: 1
    param iId :: 5
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT5_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 32
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT6_STS :: STS {
    param iComment :: "provide statistics for  INT6  Interrupt"
    param iIsUsed :: 0
    param iId :: 6
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iIsUsed :: 1
    param iId :: 6
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT6_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 64
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iIsUsed :: 1
    param iId :: 7
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT7_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 128
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iIsUsed :: 1
    param iId :: 8
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_DmaInterrupt
    param iSTSObj :: HWI_INT8_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 256
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT 9  ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT9 :: HWI {
    param iComment :: "defines the INT9  Interrupt"
    param iIsUsed :: 1
    param iId :: 9
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT9_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 512
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iIsUsed :: 1
    param iId :: 10
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT10_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 1024
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iIsUsed :: 1
    param iId :: 11
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT11_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 2048
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iIsUsed :: 1
    param iId :: 12
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT12_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 4096
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iIsUsed :: 1
    param iId :: 13
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT13_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 8192
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iIsUsed :: 1
    param iId :: 14
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT14_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 16384
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param iIsUsed :: 1
    param iId :: 15
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT15_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 32768
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT16_STS :: STS {
    param iComment :: "provides statistics for the INT16 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT16 :: HWI {
    param iComment :: "defines the INT16 Interrupt"
    param iIsUsed :: 1
    param iId :: 16
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT16_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 1
}

object HWI_INT17_STS :: STS {
    param iComment :: "provides statistics for the INT17 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT17 :: HWI {
    param iComment :: "defines the INT17 Interrupt"
    param iIsUsed :: 1
    param iId :: 17
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT17_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 2
}

object HWI_INT18_STS :: STS {
    param iComment :: "provides statistics for the INT18 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT18 :: HWI {
    param iComment :: "defines the INT18 Interrupt"
    param iIsUsed :: 1
    param iId :: 18
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT18_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 4
}

object HWI_INT19_STS :: STS {
    param iComment :: "provides statistics for the INT19 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT19 :: HWI {
    param iComment :: "defines the INT19 Interrupt"
    param iIsUsed :: 1
    param iId :: 19
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT19_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 8
}

object HWI_INT20_STS :: STS {
    param iComment :: "provides statistics for the INT20 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT20 :: HWI {
    param iComment :: "defines the INT20 Interrupt"
    param iIsUsed :: 1
    param iId :: 20
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT20_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 16
}

object HWI_INT21_STS :: STS {
    param iComment :: "provides statistics for the INT21 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT21 :: HWI {
    param iComment :: "defines the INT21 Interrupt"
    param iIsUsed :: 1
    param iId :: 21
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT21_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 32
}

object HWI_INT22_STS :: STS {
    param iComment :: "provides statistics for the INT22 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT22 :: HWI {
    param iComment :: "defines the INT22 Interrupt"
    param iIsUsed :: 1
    param iId :: 22
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT22_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 64
}

object HWI_INT23_STS :: STS {
    param iComment :: "provides statistics for the INT23 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT23 :: HWI {
    param iComment :: "defines the INT23 Interrupt"
    param iIsUsed :: 1
    param iId :: 23
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT23_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 128
}

object HWI_BERR_STS :: STS {
    param iComment :: "provides statistics for the BERRINT ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_BERR :: HWI {
    param iComment :: "defines the BERR Interrupt"
    param iIsUsed :: 1
    param iId :: 24
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_BERR_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 256
}

object HWI_DLOG_STS :: STS {
    param iComment :: "provides statistics for the DLOGINT ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_DLOG :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iIsUsed :: 1
    param iId :: 25
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_RTDX_Poll
    param iSTSObj :: HWI_DLOG_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 512
}

object HWI_RTOS_STS :: STS {
    param iComment :: "provides statistics for the RTOSINT ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RTOS :: HWI {
    param iComment :: "defines the RTOS Interrupt"
    param iIsUsed :: 1
    param iId :: 26
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_RTDX_H2TPoll
    param iSTSObj :: HWI_RTOS_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 1024
}

object HWI_SINT27_STS :: STS {
    param iComment :: "provides statistics for the SINT27 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT27 :: HWI {
    param iComment :: "defines the SINT27 Interrupt"
    param iIsUsed :: 1
    param iId :: 27
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT27_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 2048
}

object HWI_SINT28_STS :: STS {
    param iComment :: "provides statistics for the SINT28 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT28 :: HWI {
    param iComment :: "defines the SINT28 Interrupt"
    param iIsUsed :: 1
    param iId :: 28
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT28_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 4096
}

object HWI_SINT29_STS :: STS {
    param iComment :: "provides statistics for the SINT29 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT29 :: HWI {
    param iComment :: "defines the SINT29 Interrupt"
    param iIsUsed :: 1
    param iId :: 29
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT29_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 8192
}

object HWI_SINT30_STS :: STS {
    param iComment :: "provides statistics for the SINT30 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT30 :: HWI {
    param iComment :: "defines the SINT30 Interrupt"
    param iIsUsed :: 1
    param iId :: 30
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT30_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 16384
}

object HWI_SINT31_STS :: STS {
    param iComment :: "provides statistics for the SINT31 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT31 :: HWI {
    param iComment :: "defines the SINT31 Interrupt"
    param iIsUsed :: 1
    param iId :: 31
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT31_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 32768
}

object HWI_UNUSED :: HWI {
    param iComment :: "a dummy DSP interrupt for unused sources"
    param iIsUsed :: 0
    param iId :: 32
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT31_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

type SWI {
    isa ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop DependsOn :: "HWI,SIO,HST,MSGQ,PWRM"
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (211)
    prop GlobalHelpTopic :: (111)
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop uType :: (if (self.HighTimeBased()) {$a = 0} else {if (self.LowTimeBased()) {$a = 1} else {$a = 2}}, $a)
    prop STSGetMaxFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (SWI.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMaxMult :: ($a = 1)
    prop STSFilterSumMult :: (SWI.STSFilterMaxMult($1))
    prop GetPriority :: (self.pri)
    prop objectSize :: (if ((GBL.DSPTYPE == 54 && GBL.FARMODE == 0) || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {$a = (12 * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (14 * 1)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (20 * 1)} , if (GBL.DSPTYPE == 62) {$a = (11 * 1)} , $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.swi: block(0x20000) RUN_START(SWI_A_TABBEGb), RUN_END(SWI_A_TABENDb) {%8t\nSWI_A_TABBEG = SWI_A_TABBEGb / 2;%8t\nSWI_A_TABEND = SWI_A_TABENDb / 2;%4t\n} > %1s%2s\0, memSeg, pageString")
    prop GenLinkEpilogue :: ("%0t}\nSWI_A_TABLEN = %1d;\n\0, numInst")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if SWI.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if SWI.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if SWI.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop memSeg :: SWI.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop maxObjs :: (32767)
    prop numInst :: (SWI.gNumOf)
    prop dataSize :: (self.objectSize() * SWI.gNumOf)
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {"ok"})
    prop localCreate :: (STS.gNumEmbed += 1, SWI.EXECFXN = @SWI_F_exec, SWI.RUNFXN = @SWI_F_run, "ok")
    prop localDelete :: (STS.gNumEmbed -= 1, if (self.gNumOf == 1) {SWI.EXECFXN = @FXN_F_nop, SWI.RUNFXN = @FXN_F_nop} , "ok")
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: ("{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"swi.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SWI_Obj %0r;\n\0"} else {"extern SWI_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global EHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXECFXN :: @SWI_F_exec { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RUNFXN :: @SWI_F_run { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive body"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst priority :: = (self.pri + 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst pri :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
        prop Label :: "priority"
        prop JSName :: "priority"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ($a = self.pri, self.pri = $1, if (self == KNL_swi) {if ($1 != 0) {self.pri = $a, self.error("KNL_swi must remain at Priority 0.")} else {"ok"}} else {if ($1 == 0 && KNL_swi.iIsUsed == 1) {self.pri = $a, self.error("Priority 0 reserved for KNL_swi only.")} else {GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.pri = $a, self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {if ($1 > 14) {self.pri = $a, self.error("SWI can only support 15 priority levels.")} else {"ok"}}}})
    }
    inst mailbox :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mailbox"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst dorta :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst filter :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: self.STSGetMaxFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: self.STSGetSumFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: self.STSGetAvgFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst filtmaxmult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtmaxmult"
        prop NoGen :: 0
    }
    inst filtsummult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtsummult"
        prop NoGen :: 0
    }
    inst unittype :: self.uType() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: self.USETSK
    prop IsContainedIn :: SCH
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (314)
    prop InstanceHelpTopic :: (414)
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A65-B1A8-11d0-9885-0020AFEE33C6}")
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop objectSize :: (if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (27 * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (44 * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (44 * 1)} , if (GBL.DSPTYPE == 28) {$a = (40 * 1)} , if (GBL.DSPTYPE == 62 || (GBL.DSPTYPE == 54 && GBL.FARMODE == 0)) {$a = (24 * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (25 * 1)} , $a)
    prop GenLinkPrologue :: (if (self.USETSK != 0) {"SECTIONS {%4t\n.%1L: block(0x20000) {%8t\n %4S %4t\n} > %3s%5s\0, name, objSize, _bssmemSeg, linkString, pageString"} else {"_KNL_swi = 0;"})
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if TSK.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if TSK.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if TSK.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop GenLinkEpilogue :: (if (self.USETSK != 0) {"%0t}\n\0"} else {""})
    prop _objAllocDesc :: ("%8t .TSK$obj: {}")
    prop _bssmemSeg :: self.OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG
    prop AllocInst :: (if self.iAUTOSTK {"1\0, _instStackDesc, _instStackSeg, _placement"} else {"0\0"})
    prop _instStackDesc :: ("%8t .%0s$stk: block(0x20000){%12t\n *(.%0s$stk)%8t\n }\0")
    prop _self :: self
    prop _instStackSize :: self.iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instsyStackSize :: self.iSYSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: self.iSTKSEG
    prop _placement :: (0x7fffff / 2)
    prop localInit :: (KNL_swi.Create("SWI"), if (self.STACKSEG.iAllocHeap == 1) {self.STACKSEG.iReqHeapCount++, "ok"} else {self.error("TSK default stack segment must be a memory segment with a heap")})
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop uType :: (if (self.HighTimeBased()) {$a = 0} else {if (self.LowTimeBased()) {$a = 1} else {$a = 2}}, $a)
    prop STSGetMaxFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (TSK.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMaxMult :: ($a = 1)
    prop STSFilterSumMult :: (TSK.STSFilterMaxMult($1))
    prop localCreate :: (STS.gNumEmbed += 1, "ok")
    prop localCanCreate :: ($e = "ok", if (TSK.USETSK != 1) {$e = self.error("TSK manager not enabled")} , $e)
    prop localDelete :: (STS.gNumEmbed -= 1, "ok")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"tsk.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far TSK_Obj %0r;\n\0"} else {"extern TSK_Obj %0r;\n\0"})
    prop NOPFXN :: @FXN_F_nop
    prop _objId :: self.iId
    prop objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop dataSize :: ($d = 0, scan ($i; TSK) {$d += ($i.iSTKSZ + self.objectSize() * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))}, $d)
    prop minStackSize :: ($a = self.STACKSIZE, scan ($i; TSK) {if ($i.STACKSIZE < $a) {$a = $i.STACKSIZE} }, $a)
    prop maxObjs :: (32767)
    prop GetPriority :: (self.iPRI)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USETSK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable TSK Manager"
        prop JSName :: "ENABLETSK"
        prop Visible :: 1
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop NoGen :: 1
        prop Set :: (if ($1 == 0) {if (self.gNumOf > 1) {self.error("Cannot disable TSK until all TSK objects are deleted.")} else {self.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, TSK.OBJMEMSEG = MEM_NULL, TSK_idle.iSTKSEG = MEM_NULL, TSK_idle.Delete("TSK"), KNL_swi.Delete("TSK"), PRD.THOOKFXN = self.NOPFXN, if (PRD.gNumOf == 0) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @FXN_F_nop} } , self.USETSK = $1, "ok"}} else {$e = "ok", GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {$e = self.error("Current stack size inadequate to enable TSK"), break} , scan ($a; SWI) {if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {$e = self.error("Cannot enable TSK when there are SWI objects at Priority 0."), break} }, if ($e == "ok") {TSK.STACKSEG = MEM_NULL, scan ($b; MEM) {if ($b.iAllocHeap && $b != MEM_NULL) {TSK.STACKSEG = $b, break} }, self.STACKSEG.iReqHeapCount++, self.USETSK = $1, TSK.OBJMEMSEG = SWI.OBJMEMSEG, TSK_idle.iSTKSEG = self.OBJMEMSEG, TSK_idle.Create("TSK"), KNL_swi.Create("TSK"), PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (TSK.TSKTICK == "PRD") {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @PRD_F_tick} } , if (MEM.NOHEAPS) {self.STACKSEG.iReqHeapCount++} , $e} else {$e}})
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "OBJMEMSEG"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: if GBL.DSPTYPE == 54 {0x01} else {0x02}
        prop Label :: "Default stack size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global SYSTACKSIZE :: 256 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Default systack size (MAUs)"
        prop JSName :: "SYSSTACKSIZE"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global STACKSEG :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
        prop Label :: "Stack segment for dynamic tasks"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: self.USETSK && (MEM.NOHEAPS == 0)
        prop Set :: (if (self.STACKSEG.iReqHeapCount > 0) {self.STACKSEG.iReqHeapCount--} , self.STACKSEG = $1, self.STACKSEG.iReqHeapCount++, "ok")
    }
    global PRIORITY :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "PRIORITY"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Label :: "Default task priority"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global CREATEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.CREATEFXN = $1, HOOK_KNL.createFxn = self.CREATEFXN, "ok")
        prop NoGen :: 1
    }
    global VCREATEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doCreate} else {self.CREATEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.DELETEFXN = $1, HOOK_KNL.deleteFxn = self.DELETEFXN, "ok")
        prop NoGen :: 1
    }
    global VDELETEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doDelete} else {self.DELETEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.EXITFXN = $1, HOOK_KNL.exitFxn = self.EXITFXN, "ok")
        prop NoGen :: 1
    }
    global VEXITFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doExit} else {self.EXITFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DOSWITCH :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "CALLSWITCHFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOSWITCH = $1, HOOK_KNL.callSwitchFxn = self.DOSWITCH, "ok")
        prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "SWITCHFXN"
        prop Visible :: 1
        prop NoGen :: 1
        prop Writable :: self.DOSWITCH && self.USETSK
        prop Set :: (self.VSWFXN = $1, HOOK_KNL.switchFxn = self.VSWFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global SWITCHFXN :: = (if (HOOK_KNL.iIsUsed) {$i = 0, scan ($a; HOOK) {if ($a.callSwitchFxn) {$i = 1} }, if ($i) {@__HOOK_doSwitch} else {0}} else {if (self.DOSWITCH) {self.VSWFXN} else {0}}) { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "CALLREADYFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOREADY = $1, HOOK_KNL.callReadyFxn = self.DOREADY, "ok")
        prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "READYFXN"
        prop Visible :: 1
        prop Writable :: self.DOREADY && self.USETSK
        prop NoGen :: 1
        prop Set :: (self.VRDYFXN = $1, HOOK_KNL.readyFxn = self.VRDYFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global READYFXN :: = (if (HOOK_KNL.iIsUsed) {$i = 0, scan ($a; HOOK) {if ($a.callReadyFxn) {$i = 1} }, if ($i) {@__HOOK_doReady} else {0}} else {if (self.DOREADY) {self.VRDYFXN} else {0}}) { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS :: = HOOK.gNumOf { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global TSKTICK :: "PRD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "PRD,User"
        prop Label :: "TSK tick driven by"
        prop JSName :: "DRIVETSKTICK"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
        prop Set :: (if ($1 != self.TSKTICK) {if ($1 == "PRD") {PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (TSK.USETSK == 1) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @PRD_F_tick} } } , if ($1 == "User") {PRD.THOOKFXN = self.NOPFXN, if (PRD.gNumOf == 0) {if (PRD_clock.iIsUsed == 1) {PRD_clock.function = @FXN_F_nop} } } , if ($1 != "PRD" && $1 != "User") {self.error("Invalid TSK tick driver selection")} } , self.TSKTICK = $1, "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Task function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG2 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 2"
        prop JSName :: "arg2"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG3 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 3"
        prop JSName :: "arg3"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG4 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 4"
        prop JSName :: "arg4"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG5 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 5"
        prop JSName :: "arg5"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG6 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 6"
        prop JSName :: "arg6"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG7 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 7"
        prop JSName :: "arg7"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iAUTOSTK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Automatically allocate stack"
        prop JSName :: "autoAllocateStack"
        prop Set :: (if (($1 == 1) && (self.iAUTOSTK == 0)) {self.iSTKSZ = TSK.STACKSIZE} , self.iAUTOSTK = $1, "ok")
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
    }
    inst iMANSTK :: @null { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Manually allocated stack"
        prop JSName :: "manualStack"
        prop Visible :: 1
        prop Writable :: self.iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Stack size (MAUs)"
        prop JSName :: "stackSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = $1, self.iSTKSZ = ($1 - ($1 - 1) % 2 + 1), GlobalStatus.gDirty = 1, "ok")
    }
    inst iSYSTKSZ :: TSK.SYSTACKSIZE { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "SyStack size (MAUs)"
        prop JSName :: "sysStackSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = $1, self.iSYSTKSZ = ($1 - ($1 - 1) % 2 + 1), GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTKSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
        prop Label :: "Stack Memory Segment"
        prop JSName :: "stackMemSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY { 
        prop Label :: "Priority"
        prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if (self == TSK_idle) {if ($1 == 0) {"ok"} else {self.error("Cannot change the priority of the idle task.")}} else {if ($1 == 0) {self.error("Priority 0 is reserved for the system idle task")} else {self.iPRI = $1, "ok"}})
    }
    inst iENV :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Environment pointer"
        prop JSName :: "envPointer"
        prop Visible :: 1
        prop Writable :: self.iDelUser != "TSK"
        prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't shut down system while this task is still running"
        prop JSName :: "exitFlag"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Task Name on Target"
        prop JSName :: "allocateTaskName"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iSTATREG :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Label :: "Initial Status Register value"
        prop Visible :: 0
        prop Writable :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst filter :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: self.STSGetMaxFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: self.STSGetSumFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: self.STSGetAvgFmt() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst filtmaxmult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtmaxmult"
        prop NoGen :: 0
    }
    inst filtsummult :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filtsummult"
        prop NoGen :: 0
    }
    inst unittype :: self.uType() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: @IDL_F_loop
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iSYSTKSZ :: 256
    param iSTKSEG :: DARAM
    param iPRI :: 0
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param iSTATREG :: 0
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

object KNL_swi :: SWI {
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This object cannot be deleted in DSP/BIOS."
    param function :: @_KNL_run
    param pri :: 0
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (106)
    prop InstanceHelpTopic :: (206)
    prop InstancePropertyPage :: ("{586735F1-770B-11d0-A61F-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{586735F0-770B-11d0-A61F-0000C070F3E9}")
    prop objectSize :: (if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {$a = (2 * 1)} else {$a = (1 * 1)}, $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: block(0x20000), RUN_START(%1U_A_TABBEGb) {%8t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2;%4t\n} > %3s%5s\0, name, _objSize, _memSeg, _linkString, _pageString")
    prop GenLinkEpilogue :: ("%4t\n.%1Lcal: block(0x20000), RUN_START(%1U_A_CALBEGb) {%8t\n%1U_A_CALBEG = %1U_A_CALBEGb / 2;%4t\n} > %3s%5s %0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj")
    prop _linkString :: "*(.%1L)"
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: if GBL.DSPTYPE == 62 {""} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if IDL.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if IDL.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if IDL.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop _nilBusyObj :: (if ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) {"IDL_busyObj = 0;\n"} else {""})
    prop _memSeg :: IDL.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop dataSize :: (self.objectSize() * (IDL.gNumOf + 1))
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop idlFxnSum :: ($a = 0, scan ($i; IDL) {$a += $i.cycles}, $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global AUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Auto calculate idle loop instruction count"
        prop JSName :: "AUTOCALCULATE"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER
        prop Set :: (if ($1 == 1 && CLK.USETIMER == 0) {self.error("CLK must be enabled to do idle loop intruction count")} else {if ($1 == 1 && GBL.ENABLEINST == 0) {self.error("Real Time Analysis must be enabled to do idle loop instruction count")} else {self.AUTOCALCULATE = $1, "ok"}})
        prop NoGen :: 1
    }
    global USECLKIDLTIME :: = IDL.AUTOCALCULATE { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global USEIDLBUSYOBJ :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALIBRFXN :: = (if (IDL.AUTOCALCULATE == 1) {if TSK.USETSK {@_IDL_stub} else {@_IDL_calibrate}} else {@GBL_NULL}) { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALIBRERROR :: = (if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {6} else {0}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Error"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global LOOPOVERHEAD :: 0 { 
        prop Label :: "Idle Loop Instruction Count"
        prop JSName :: "LOOPINSTCOUNT"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.AUTOCALCULATE == 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst cycles :: 0 { 
        prop Label :: "CPU cycles"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 1
    }
    inst calibration :: 1 { 
        prop Label :: "Include in CPU load calibration"
        prop JSName :: "calibration"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to compute CPU load and can't be deleted"
    param function :: @IDL_F_busy
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to accumulate CPU load data and can't be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHwi :: HWI_UNUSED { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
}

object Timer_0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
}

object Timer_1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
}

object Timer_2 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
}

type LOG {
    isa ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (207)
    prop GlobalHelpTopic :: (107)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name")
    prop objectSize :: (if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (10 * 1)} , if (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 54 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {$a = (6 * 1)} , $a)
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop GenLinkEpilogue :: ("%0tLOG_A_TABLEN = %1d; _LOG_A_TABLEN = %1d;\n\0, numInst")
    prop _instAllocDesc :: ("%8t /* %0s buffer */\n .%0s$buf: block(0x20000) align = 0x%1x {}\0, _objAlign")
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _objAlign :: if GBL.DSPTYPE == 55 {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2} else {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)}
    prop _objMemSeg :: self.bufseg
    prop LogType :: self.iType
    prop LogFormat :: self.iFormat
    prop pageString :: (if GBL.DSPTYPE == 62 {""} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if LOG.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if LOG.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if LOG.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}})
    prop numInst :: (LOG.gNumOf)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"log.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LOG_Obj %0r;\n\0"} else {"extern LOG_Obj %0r;\n\0"})
    prop dataSize :: ($d = 0, scan ($i; LOG) {if ($i.IsConfObj()) {$d += $i.buflen} , $d += self.objectSize()}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst buflen :: 64 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "buflen (words)"
        prop JSName :: "bufLen"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.buflen = $1, "ok")
    }
    inst logtype :: "circular" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "circular,fixed"
        prop Label :: "logtype"
        prop JSName :: "logType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iType :: "printf" { 
        prop Label :: "datatype"
        prop JSName :: "dataType"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "printf,raw data"
        prop Visible :: 1
        prop Writable :: if self.iType == "system" {0} else {1}
        prop NoGen :: 0
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" { 
        prop Label :: "format"
        prop JSName :: "format"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if self.iType == "raw data" {1} else {0}
        prop NoGen :: 0
    }
}

object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "LOG"
    param iDelMsg :: "LOG_system is a system log and cannot be deleted."
    param bufseg :: DARAM
    param buflen :: 512
    param logtype :: "circular"
    param iType :: "system"
    param iFormat :: "0x%x, 0x%x, 0x%x"
}

type PIP {
    isa ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (109)
    prop InstanceHelpTopic :: (209)
    prop name :: "PIP"
    prop maxObjs :: (32767)
    prop objectSize :: (if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (27 * 1)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (34 * 1)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (30 * 1)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (50 * 1)} , if (GBL.DSPTYPE == 62) {$a = (25 * 1)} , $a)
    prop dataSize :: ($b = 0, scan ($i; PIP) {if ($i.IsConfObj()) {$b += ((6) + $i.framesize) * $i.numframes + self.objectSize()} }, $b)
    prop InstancePropertyPage :: ("{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: ("ok")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name")
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop GenLinkEpilogue :: ("%0tPIP_A_TABLEN = %1d;\n\0, numInst")
    prop _instAllocDesc :: (if self.bufalign > 0 {"%8t /* %0s buffer */\n .pip%1d: block(0x20000) align = 0x%2x {}\0, _objId, _objAlign"} else {"%8t /* %0s buffer */\n .pip%1d: block(0x20000){}\0, _objId"})
    prop _placement :: (0x7fffff / 2)
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign * 2
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop numInst :: (HST.gNumOf + PIP.gNumOf)
    prop mkId :: (self.iId = self.gNextId++, self.gNumOf++, self.iId)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"pip.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PIP_Obj %0r;\n\0"} else {"extern PIP_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 2 { 
        prop NoGen :: 0
    }
    global gNextId :: 0
    global OBJSIZE :: = self._objSize
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
    }
    inst bufalign :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "bufAlign"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 == 0) {$e = self.error("Cannot set align value to 0")} else {self.bufalign = $1}, $e)
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: if GBL.DSPTYPE == 62 {0x02} else {0x01 | 0x02}
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {GlobalStatus.gDirty = 1, self.framesize = $1, "ok"})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Pipes must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst monitor :: "reader" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "monitor"
        prop Enum :: "reader,writer,none"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst bufFrameAlign :: = self._objAlign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (310)
    prop InstanceHelpTopic :: (410)
    prop InstancePropertyPage :: ("{D01ACC04-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC05-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .sem: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (8 + 3)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (10 + 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (8 + 3)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (16 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (16 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 + 4)} , if (GBL.DSPTYPE == 28) {$a = (16 + 6)} , $a)
    prop dataSize :: (SEM.objectSize * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sem.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SEM_Obj %0r;\n\0"} else {"extern SEM_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Initial semaphore count"
        prop JSName :: "count"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (307)
    prop InstanceHelpTopic :: (407)
    prop InstancePropertyPage :: ("{0EB45D44-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D45-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,	_bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .mbx: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0 _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$que: block(0x20000) align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize")
    prop _instMemSeg :: self.iMbxSeg
    prop _qElemSize :: (if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {$a = self.iMsgSize, if ($a & 0x1) {$a += 1} , (4 + $a) * self.iMbxLength * 2} else {if (GBL.DSPTYPE == 28) {$a = self.iMsgSize, if ($a & 0x1) {$a += 1} , (4 + $a) * self.iMbxLength} else {$a = self.iMsgSize, $b = GBL.DSPWORDSIZE / GBL.DSPCHARSIZE, $c = $a & ($b - 1), if ($c != 0) {$a = $a + ($b - $c)} , (4 + $a) * self.iMbxLength}})
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (29)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (28)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (24)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (46)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (46)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (28)} , if (GBL.DSPTYPE == 28) {$a = (46)} , $a)
    prop dataSize :: ($d = 0, scan ($i; MBX) {$d += (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + self.objectSize())}, $d)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"mbx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far MBX_Obj %0r;\n\0"} else {"extern MBX_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iMsgSize :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Message Size"
        prop JSName :: "messageSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Message size cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMsgSize = $1, "ok"})
    }
    inst iMbxLength :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Mailbox Length"
        prop JSName :: "length"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Mailbox length cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMbxLength = $1, "ok"})
    }
    inst iMbxSeg :: MBX.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Element memory segment"
        prop JSName :: "elementSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (309)
    prop InstanceHelpTopic :: (409)
    prop InstancePropertyPage :: ("{D01ACC01-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC02-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .que: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (2)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (2)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (2)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (2)} , if (GBL.DSPTYPE == 28) {$a = (4)} , $a)
    prop dataSize :: (QUE.objectSize * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"que.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far QUE_Obj %0r;\n\0"} else {"extern QUE_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (306)
    prop InstanceHelpTopic :: (406)
    prop InstancePropertyPage :: ("{0EB45D40-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D41-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .lck: block(0x20000){}")
    prop _objAllocDesc :: ("%8t .LCK$obj: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (10)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (12)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (10)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (20)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (20)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (12)} , if (GBL.DSPTYPE == 28) {$a = (20)} , $a)
    prop dataSize :: (LCK.objectSize * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"lck.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LCK_Obj %0r;\n\0"} else {"extern LCK_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type STS {
    isa ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (212)
    prop GlobalHelpTopic :: (112)
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name")
    prop localInit :: (if (PRD.CALLBACKOBJ != nil) {self.error("STS initialization failure")} , PRD.CALLBACKOBJ = STS)
    prop objectSize :: ((4 * 2))
    prop _placement :: (0x7fffff / 2)
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: STS.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop dataSize :: (self.objectSize() * (STS.gNumOf + STS.gNumEmbed))
    prop maxObjs :: (32767)
    prop InstancePropertyPage :: ("{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: (self.format)
    prop STSGetSumFmt :: (self.format)
    prop STSGetAvgFmt :: ("%.2f")
    prop STSFilterSum :: ((self.iA * $1 + self.iB * $2) / (1.0 * self.iC))
    prop STSFilterMax :: ((self.iA * $1 + self.iB) / (1.0 * self.iC))
    prop HighTimeBased :: (if self.unittype == "High resolution time based" {1} else {0})
    prop LowTimeBased :: (if self.unittype == "Low resolution time based" {1} else {0})
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sts.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far STS_Obj %0r;\n\0"} else {"extern STS_Obj %0r;\n\0"})
    prop modifiable :: ((if (self.iDelUser == "USER" || self.iDelUser == "HWI") {1} else {0}))
    prop untype :: (if (self.unittype == "Not time based") {$a = 2} , if (self.unittype == "High resolution time based") {$a = 0} , if (self.unittype == "Low resolution time based") {$a = 1} , $a)
    prop optype :: (if (self.operation == "Nothing") {$a = 0} , if (self.operation == "A * x") {$a = 1} , if (self.operation == "A * x + B") {$a = 2} , if (self.operation == "(A * x + B) / C") {$a = 3} , $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst prev :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop JSName :: "previousVal"
        prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
        prop Set :: (self.prev = $1, self.prevlow = $1 & 0xffff, self.prevhigh = ($1 >> 16) & 0xffff, "ok")
    }
    inst format :: "%g" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "format"
        prop NoGen :: 1
    }
    inst filter :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: "%g" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: "%g" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: "%.2f" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst unittype :: "Not time based" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not time based,High resolution time based,Low resolution time based"
        prop Label :: "unit type"
        prop JSName :: "unitType"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (self.unittype = $1, if ($1 == "High resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {if ($1 == "Low resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "Nothing"}}, "ok")
    }
    inst operation :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
        prop Label :: "host operation"
        prop JSName :: "operation"
        prop Visible :: 1
        prop Writable :: ((self.unittype != "Low resolution time based") && self.modifiable())
        prop NoGen :: 1
        prop Set :: (self.operation = $1, if ($1 == "Nothing" && self.unittype != "High resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1} else {if ($1 == "A * x") {self.iB = 0, self.iC = 1} else {if ($1 == "A * x + B") {self.iC = 1} }}, "ok")
    }
    inst op :: = self.optype() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst uType :: = self.untype() { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iA :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && !(self.unittype != "Not time based" || self.operation == "Nothing"))
        prop Label :: "A"
        prop JSName :: "numA"
        prop NoGen :: 0
    }
    inst iB :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && !(self.unittype == "Low resolution time based" || self.operation == "Nothing" || self.operation == "A * x"))
        prop Label :: "B"
        prop JSName :: "numB"
        prop NoGen :: 0
    }
    inst iC :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (self.modifiable() && (self.unittype == "Not time based" && self.operation == "(A * x + B) / C"))
        prop Label :: "C"
        prop JSName :: "numC"
        prop NoGen :: 0
    }
    inst prevhigh :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    inst prevlow :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (313)
    prop InstanceHelpTopic :: (413)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop AllocType :: (if self.PUTCFXN == @_UTL_doPutc {"2\0, _globalAllocDesc,	_memSeg, _midPlace, 	      _traceString, _traceSeg, _midPlace"} else {"1\0, _globalAllocDesc,	_memSeg, _midPlace"})
    prop _globalAllocDesc :: ("%8t .sys: block(0x20000)    {}")
    prop _traceString :: ("%8t .trace: block(0x20000) fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize")
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: (SYS.TRACESIZE * 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACESIZE :: 512 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%d"
        prop Style :: 0x01 | 0x02
        prop Label :: "Trace Buffer Size"
        prop JSName :: "TRACESIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TRACESEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Trace Buffer Memory"
        prop JSName :: "TRACESEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Abort Function"
        prop JSName :: "ABORTFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Error Function"
        prop JSName :: "ERRORFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Putc Function"
        prop JSName :: "PUTCFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "DIO,DGN,DHL,DPI"
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (311)
    prop InstanceHelpTopic :: (411)
    prop InstancePropertyPage :: ("{7C4C9A60-763E-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7C4C9A61-763E-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .SIO$bss: block(0x20000) {%12t\n *(.SIO$bss)%8t\n }")
    prop _objAllocDesc :: ("%8t .SIO$obj: block(0x20000) {%12t\n *(.SIO$obj)%8t\n }")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instBufDesc, _instBufSeg, _placement")
    prop _instBufDesc :: (if self.iAlign > 1 {"%8t .%0s$bufs: block(0x20000) align = 0x%1x {}\0, _objAlign"} else {"%8t .%0s$bufs: block(0x20000) {}"})
    prop _objAlign :: self.iAlign * 2
    prop _instBufSeg :: self.iBufSegid
    prop defDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, break} }} }, $j)
    prop devList :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, scan ($a; DIO) {if ($a == $i) {$i.numTimeUse++} }, break} }} }, $j)
    prop setDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($i == $1) {$j = $i} }} }, $j)
    prop localCanCreate :: (if (self.defDev == nil) {self.error("A driver device must be created before creating a stream.")} else {"ok"})
    prop localDelete :: (scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, "ok")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sio.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SIO_Obj %0r;\n\0"} else {"extern SIO_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Only Issue/Reclaim Model"
        prop JSName :: "USEISSUERECLAIM"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.USEISSUERECLAIM = $1, if ($1 == 1) {scan ($i; SIO) {$i.iModelName = "Issue/Reclaim"}} , "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: SIO.devList { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop TypeTest :: $1.isDriver == 1
        prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
        prop Label :: "Device"
        prop JSName :: "deviceName"
        prop Set :: (if (($1.iIsTerminal == 0) && (self.iDevCtrlParam == "")) {self.error("To select a stacking device, enter first a terminal device in Device Control String")} else {if ($1.iIsVirtual == 1) {self.error("The device you have selected is a virtual instance, you must select a non-virtual device")} else {scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, scan ($b; DIO) {if ($b == $1) {$1.numTimeUse++} }, self.iDevice = self.setDev($1), "ok"}})
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevCtrlParam :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Device Control String"
        prop JSName :: "controlParameter"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevId :: = self.iDevice.iDevId
    inst iFxns :: = self.iDevice.iFxns
    inst iMode :: "input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "input,output"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufsize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Buffer size"
        prop JSName :: "bufSize"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iNbufs :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Number of buffers"
        prop JSName :: "numBufs"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufSegid :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Place buffers in memory segment"
        prop JSName :: "bufSegId"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iAlign :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "Buffer alignment"
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iFlush :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Flush"
        prop JSName :: "flush"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iModelName :: "Standard" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Standard,Issue/Reclaim"
        prop Label :: "Model"
        prop JSName :: "modelName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($e = "ok", if (self.USEISSUERECLAIM == 1) {if ($1 == "Standard") {$e = self.error("SIO Issue/Reclaim model support selected")} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}, $e)
    }
    inst iAllocBuf :: = self.iSaveAllocBuf { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Static Buffer(s)"
        prop JSName :: "allocStaticBuf"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (self.iSaveAllocBuf = $1, "ok")
    }
    inst iSaveAllocBuf :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
        prop Visible :: 0
        prop Writable :: 0
    }
    inst iTimeout :: = if self.iModel == "SIO_ISSUERECLAIM" {self.iSaveTimeout} else {-1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timeout for I/O operation"
        prop JSName :: "timeout"
        prop Visible :: 1
        prop Writable :: self.iModel == "SIO_ISSUERECLAIM"
        prop Set :: (self.iSaveTimeout = $1, "ok")
    }
    inst iSaveTimeout :: -1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback function"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "callback function"
        prop JSName :: "callBackFxn"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
}

type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: self.USEGIO
    prop IsContainedIn :: IOF
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (320)
    prop InstanceHelpTopic :: (420)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _midPlace")
    prop _globalAllocDesc :: ("%8t .gio: block(0x20000)    {}")
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEGIO :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable General Input/Output Manager"
        prop JSName :: "ENABLEGIO"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CREATEFXN :: = if self.USEGIO == 1 {@_SEM_create} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create Function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global DELETEFXN :: = if self.USEGIO == 1 {@_SEM_delete} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete Function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global PENDFXN :: = if self.USEGIO == 1 {@_SEM_pend} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Pend Function"
        prop JSName :: "PENDFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global POSTFXN :: = if self.USEGIO == 1 {@_SEM_post} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Post Function"
        prop JSName :: "POSTFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
}

type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} , if (self.devCount() > 0) {"1\0, _devtableDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .dev: block(0x20000){}")
    prop _devtableDesc :: ("%8t .devtable: block(0x20000){}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    prop DependsOn :: "HWI,PWRM"
    prop devCount :: ($i = nil, $a = 0, scan ($i; nil) {if ($i.isDriver == 1) {$a = $a + $i.gNumOf} }, $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "DEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (315)
    prop InstanceHelpTopic :: (415)
    prop InstancePropertyPage :: ("{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .udev: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (if self.fxnTableType == "DEV_Fxns" {"DEV_SIOTYPE"} else {"DEV_IOMTYPE"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iInit :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "init function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iInit = $1, self.initFxn = self.iInit, "ok")
    }
    inst iFxns :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function table ptr"
        prop JSName :: "fxnTable"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst fxnTableType :: "DEV_Fxns" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_Fxns,IOM_Fxns"
        prop Label :: "function table type"
        prop JSName :: "fxnTableType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst driverType :: = self._driverType { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
        prop Visible :: 0
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device id"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iDevId = $1, self.deviceId = self.iDevId, "ok")
    }
    inst iParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device params ptr"
        prop JSName :: "params"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst deviceId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst initFxn :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst iIsStacking :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stacking Device"
        prop JSName :: "stackingDevice"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device global data ptr"
        prop JSName :: "deviceGlobalDataPtr"
        prop Visible :: 1
        prop Writable :: self.fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal :: = if self.fxnTableType == "DEV_Fxns" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (319)
    prop InstanceHelpTopic :: (419)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dio: {}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop isDriver :: (1)
    prop mdObject :: ($h = nil, $j = nil, scan ($h; UDEV) {if ($h.driverType == "DEV_IOMTYPE") {$j = $h, break} }, $j)
    prop localCanCreate :: (if (self.mdObject == nil) {self.error("An IOM type device must be created first.")} else {"ok"})
    prop numTsk :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 0) {$a = $a + $h.numTimeUse} }, $a)
    prop numSwi :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 1) {$a = $a + $h.numTimeUse} }, $a)
    prop functionTablePtr :: (if (self.STATIC) {if (self.useCallBackFxn) {@_DIO_cbStaticFxns} else {@_DIO_tskStaticFxns}} else {if (self.useCallBackFxn) {@_DIO_cbDynamicFxns} else {@_DIO_tskDynamicFxns}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STATIC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Create all DIO Objects Statically"
        prop JSName :: "STATICCREATE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global NUMTSKBASE :: = self.numTsk { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TSK based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global NUMSWIBASE :: = self.numSwi { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "SWI based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback version of DIO function table (for SWI)"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst fxnsTable :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst deviceName :: self.mdObject { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: UDEV
        prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label :: "device name"
        prop JSName :: "deviceName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst chanParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "channel parameters"
        prop JSName :: "chanParams"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst numTimeUse :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFxns :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (302)
    prop InstanceHelpTopic :: (402)
    prop InstancePropertyPage :: ("{054FE166-B014-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{054FE167-B014-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dgn: block(0x20000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: "user" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: if GBL.DSPARITHMETIC == "FLOAT" {"user,sine,random,constant,printFloat,printHex,printInt"} else {"user,sine,random,constant,printHex,printInt"}
        prop Label :: "Device category"
        prop JSName :: "device"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a != self.iDevice) {self.iDevice = $a, self.iUserFxn = @_FXN_F_nop} , if ($a == "user") {self.iUserFxn = self.iSaveUserFxn} , if ($a == "printFloat") {self.iUserFxn = @_DGN_printFloat} , if ($a == "printHex") {self.iUserFxn = @_DGN_printHex} , if ($a == "printInt") {self.iUserFxn = @_DGN_printInt} , "ok")
    }
    inst iUseDefaults :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use default parameters"
        prop Visible :: 1
        prop JSName :: "useDefaultParam"
        prop Writable :: self.iDevice == "sine" || self.iDevice == "constant" || self.iDevice == "random" || self.iDevice == "user"
    }
    inst iDevId :: = if self.iDevice == "constant" {@DGN_CONST} else {if self.iDevice == "random" {@DGN_RAND} else {if self.iDevice == "sine" {@DGN_SINE} else {@DGN_USER}}} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Device ID"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iConstant :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Constant value"
        prop JSName :: "constant"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "constant" || self.iDevice == "user")
    }
    inst iRandSeed :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Seed value"
        prop JSName :: "seedValue"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandLower :: if GBL.DSPARITHMETIC == "FIXED" {-32767} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Lower limit"
        prop JSName :: "lowerLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandUpper :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Upper limit"
        prop JSName :: "upperLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iSineGain :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Gain"
        prop JSName :: "gain"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineFreq :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1000.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Frequency (Hz)"
        prop JSName :: "frequency"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSinePhase :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Phase (radians)"
        prop JSName :: "phase"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineRate :: if GBL.DSPARITHMETIC == "FIXED" {256} else {44000} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Sample rate (samples/sec)"
        prop JSName :: "rate"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iUserFxn :: if self.iDevice == "printFloat" {@_DGN_printFloat} else {if self.iDevice == "printHex" {@_DGN_printHex} else {if self.iDevice == "printInt" {@_DGN_printInt} else {@_FXN_F_nop}}} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
        prop Set :: (self.iUserFxn = $1, self.iSaveUserFxn = self.iUserFxn, "ok")
    }
    inst iSaveUserFxn :: @_FXN_F_nop { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iUserArg :: = 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function argument"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
    }
    inst iFxns :: @_DGN_FXNS { 
        prop NoGen :: 1
    }
}

type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = (19)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (22)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (19)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (34)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (34)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (22)} , if (GBL.DSPTYPE == 28) {$a = (34)} , $a)
    prop dataSize :: (DHL.objectSize * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop localCanCreate :: (if (self.gChannelsAvailable > 0) {"ok"} else {self.warning("No HST channels are available for a new DHL device.")})
    prop localCreate :: (self.gChannelsAvailable--, self.seizeHSTChannel(self.iHSTChannel), "ok")
    prop seizeHSTChannel :: ($1.iDelUser = "DHL", $1.iDHLAvailable = 0, $1.notify = @_DHL_notify, $1.arg0 = $1.iId, "ok")
    prop localDelete :: (self.gChannelsAvailable++, self.releaseHSTChannel(self.iHSTChannel), "ok")
    prop releaseHSTChannel :: ($1.iDelUser = "USER", $1.iDHLAvailable = 1, $1.notify = @_FXN_F_nop, $1.arg0 = 0, "ok")
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: "%8t .dhl: block(0x20000){}"
    prop _memSeg :: self.OBJMEMSEG
    prop _placement :: (0x7fffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gChannelsAvailable :: 0
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHSTChannel :: (scan ($i; HST) {if ($i.iDHLAvailable == 1) {$a = $i} }, $a) { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Underlying HST Channel"
        prop JSName :: "hstChannel"
        prop MemberType :: HST
        prop MemberTest :: (if (($1.iDHLAvailable == 1) || ($1 == self.iHSTChannel)) {1} else {0})
        prop Set :: (if ($1.iDHLAvailable != 1) {self.error("This channel is already in use.")} else {self.releaseHSTChannel(self.iHSTChannel), self.seizeHSTChannel($1), self.iHSTChannel = $1, "ok"})
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode :: = self.iHSTChannel.mode { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDevId :: = (self.iHSTChannel.iId) { 
        prop NoGen :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS { 
        prop NoGen :: 1
    }
}

type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (304)
    prop InstanceHelpTopic :: (404)
    prop InstancePropertyPage :: ("{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop localCreate :: (self.gCurDevId += 1, "ok")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gCurDevId :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop Set :: (self.error("DPI.iDevId parameter no longer settable, it is now handled automatically"))
    }
    inst iIsVirtual :: 0 { 
        prop Label :: "Allow virtual instances of this device."
        prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 1) {$a = "ok", $b = 1, scan ($i; SIO) {if ($i.iDevice == self) {$a = self.error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"), $b = 0} }, if ($b == 1) {self.iIsVirtual = 1} , $a} else {self.iIsVirtual = 0, "ok"})
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DPI_FXNS { 
        prop NoGen :: 1
    }
}

type MSGQ {
    isa Module
    prop Visible :: 1
    prop name :: "MSGQ"
    prop Label :: "MSGQ - Message Queue Manager"
    prop IsConfMod :: self.USEMSGQ
    prop IsContainedIn :: IOF
    prop DependsOn :: "GIO,SIO"
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (323)
    prop InstanceHelpTopic :: (423)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEMSGQ :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable MSGQ Manager"
        prop JSName :: "ENABLEMSGQ"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (318)
    prop InstanceHelpTopic :: (418)
    prop localCreate :: (if (self.gNumOf == 0) {HOOK_KNL.iIsUsed = 1, self.mkId(0)} , "ok")
    prop localDelete :: (if (self.gNumOf == 2) {HOOK_KNL.iIsUsed = 0, self.rmId} , "ok")
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global KNLID :: = (HOOK_KNL.Order - 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst initFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Initialization function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "createFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "deleteFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "exitFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "callSwitchFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "switchFxn"
        prop Visible :: 1
        prop Writable :: self.callSwitchFxn
    }
    inst callReadyFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "callReadyFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "readyFxn"
        prop Visible :: 1
        prop Writable :: self.callReadyFxn
    }
    inst Order :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object HOOK_KNL :: HOOK {
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: @_FXN_F_nop
    param deleteFxn :: @_FXN_F_nop
    param exitFxn :: @_FXN_F_nop
    param callSwitchFxn :: 0
    param switchFxn :: @_FXN_F_nop
    param callReadyFxn :: 0
    param readyFxn :: @_FXN_F_nop
    param Order :: 1
    param iPri :: 0
}

type PWRM {
    isa Module
    prop Visible :: 0
    prop name :: "PWRM"
    prop Label :: "PWRM - Power Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "HWI"
    prop GlobalIcon :: 185
    prop InstanceIcon :: 186
    prop GlobalHelpTopic :: (322)
    prop InstanceHelpTopic :: (422)
    prop IsConfMod :: 1
    prop InstancePropertyPage :: ("{000FFB50-0419-11d3-B053-0020AFEF4449}")
    prop GlobalPropertyPage :: ("{43959450-0419-11d3-B053-0020AFEF4449}")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .pwrmdb: block(0x20000)   {}")
    prop _memSeg :: self.PWRM_DEVICEDBMEMSEG
    prop _placement :: (0x7fffff / 2)
    prop pslConfigLibName :: (if GBL.DSPSUBTYPE == 5503 {"PSL_cfg_c5503.a55L"} else {if GBL.DSPSUBTYPE == 5507 {"PSL_cfg_c5507.a55L"} else {if GBL.DSPSUBTYPE == 5509 {"PSL_cfg_c5509a.a55L"} else {if GBL.DSPSUBTYPE == 5510 {"PSL_cfg_c5510.a55L"} else {""}}}})
    prop PWRM_idlemask_update :: (self.PWRMCPUMASK | self.PWRMDMAMASK | self.PWRMCACHEMASK | self.PWRMPERIPHMASK | self.PWRMCLKGENMASK | self.PWRMEMIFMASK)
    prop PWRMCPUMASK :: (if (self.PWRM_CPU == 1) {0x01} else {0x0})
    prop PWRMDMAMASK :: (if (self.PWRM_DMA == 1) {0x02} else {0x0})
    prop PWRMCACHEMASK :: (if (self.PWRM_CACHE == 1) {0x04} else {0x0})
    prop PWRMPERIPHMASK :: (if (self.PWRM_PERIPH == 1) {0x08} else {0x0})
    prop PWRMCLKGENMASK :: (if (self.PWRM_CLKGEN == 1) {0x10} else {0x0})
    prop PWRMEMIFMASK :: (if (self.PWRM_EMIF == 1) {0x20} else {0x0})
    prop PWRM_capsmask_update :: (self.PWRMBOOTHOOKF | self.PWRMIDLEDOMAINSF | self.PWRMVFSCALINGF | self.PWRMSCALEVF | self.PWRMWAITFORVF | self.PWRMDEEPSLEEPF | self.PWRMWAITRESTARTF | self.PWRMSNOOZEF | self.PWRMDEVICEINITF | self.PWRMTRACKINGF | self.PWRMADAPTCLKF)
    prop PWRMBOOTHOOKF :: (if (self.PWRM_BOOTHOOK == 1) {0x100} else {0x0})
    prop PWRMADAPTCLKF :: (if (self.PWRM_ADAPTCLK == 1) {0x80} else {0x0})
    prop PWRMIDLEDOMAINSF :: (if (self.PWRM_IDLEDOMAINS == 1) {0x40} else {0x0})
    prop PWRMVFSCALINGF :: (if (self.PWRM_SCALING == 1) {0x8} else {0x0})
    prop PWRMSCALEVF :: (if (self.PWRM_SCALEV == 1) {0x10} else {0x0})
    prop PWRMWAITFORVF :: (if (self.PWRM_WAITV == 1) {0x20} else {0x0})
    prop PWRMDEEPSLEEPF :: (if (self.PWRM_ENSLEEP == 1) {0x1} else {0x0})
    prop PWRMWAITRESTARTF :: (if (self.PWRM_ENSLEEPUNTILRESTART == 1) {0x2} else {0x0})
    prop PWRMSNOOZEF :: (if (self.PWRM_ENSNOOZE == 1) {0x4} else {0x0})
    prop PWRMDEVICEINITF :: (if (self.PWRM_DEVICEINIT == 1) {0x400} else {0x0})
    prop PWRMTRACKINGF :: (if (self.PWRM_RESOURCETRACKING == 1) {0x200} else {0x0})
    prop PWRM_DS_idlemask_update :: (self.PWRMDSCPUMASK | self.PWRMDSDMAMASK | self.PWRMDSCACHEMASK | self.PWRMDSPERIPHMASK | self.PWRMDSCLKGENMASK | self.PWRMDSEMIFMASK)
    prop PWRMDSCPUMASK :: (if (self.PWRM_DS_CPU == 1) {0x01} else {0x0})
    prop PWRMDSDMAMASK :: (if (self.PWRM_DS_DMA == 1) {0x02} else {0x0})
    prop PWRMDSCACHEMASK :: (if (self.PWRM_DS_CACHE == 1) {0x04} else {0x0})
    prop PWRMDSPERIPHMASK :: (if (self.PWRM_DS_PERIPH == 1) {0x08} else {0x0})
    prop PWRMDSCLKGENMASK :: (if (self.PWRM_DS_CLKGEN == 1) {0x10} else {0x0})
    prop PWRMDSEMIFMASK :: (if (self.PWRM_DS_EMIF == 1) {0x20} else {0x0})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PWRM_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable PWRM Manager"
        prop JSName :: "ENABLE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_IDLEDOMAINS == 1) {$e = self.error("Idling of DSP domains (Idling page) must be disabled before disabling the Power Manager")} else {self.PWRM_ENABLE = $1}} else {self.PWRM_ENABLE = $1}, $e)
    }
    global PWRM_BOOTHOOK :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call user hook function at boot time"
        prop JSName :: "BOOTHOOK"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 == 0) {self.PWRM_BOOTHOOKFXN = @_FXN_F_nop} , self.PWRM_BOOTHOOK = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), $e)
    }
    global PWRM_BOOTHOOKFXN :: @_FXN_F_nop { 
        prop Label :: "Function"
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "BOOTHOOKFXN"
        prop Visible :: 1
        prop Writable :: self.PWRM_BOOTHOOK && self.PWRM_ENABLE
        prop NoGen :: 0
    }
    global PWRM_ADAPTCLK :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reprogram BIOS clock after frequency scaling"
        prop JSName :: "ADAPTCLK"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER && self.PWRM_ENABLE && self.PWRM_SCALING
        prop NoGen :: 0
        prop Set :: (self.PWRM_ADAPTCLK = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate before PWRM insert "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PWRM_DEVICEINIT :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable device initialization by PWRM"
        prop JSName :: "DEVICEINIT"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE && ((GBL.DSPSUBTYPE == 5509) || (GBL.DSPSUBTYPE == 5503) || (GBL.DSPSUBTYPE == 5507) || (GBL.DSPSUBTYPE == 2420) || (GBL.DSPSUBTYPE == 2320))
        prop NoGen :: 1
        prop Set :: (self.PWRM_DEVICEINIT = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_RESOURCETRACKING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable resource tracking by PWRM"
        prop JSName :: "RESOURCETRACKING"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE && ((GBL.DSPSUBTYPE == 5509) || (GBL.DSPSUBTYPE == 5503) || (GBL.DSPSUBTYPE == 5507) || (GBL.DSPSUBTYPE == 2420) || (GBL.DSPSUBTYPE == 2320))
        prop NoGen :: 1
        prop Set :: (self.PWRM_RESOURCETRACKING = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_DEVICEDBMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "MEM section for device database"
        prop JSName :: "DEVICEDBMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global PWRM_IDLEDOMAINS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle DSP domains in the BIOS idle loop"
        prop JSName :: "IDLEDOMAINS"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ($e = "ok", if ($1 != self.PWRM_IDLEDOMAINS) {if ($1 == 1) {PWRM_idleDomains.Create("IDL"), PWRM_idleDomains.function = @_PWRM_F_idleDomains, self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0} else {PWRM_idleDomains.Delete("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE}, self.PWRM_IDLEDOMAINS = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update()} , $e)
    }
    global PWRM_EMIF :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    EMIF"
        prop JSName :: "IDLEEMIF"
        prop Visible :: 1
        prop Writable :: self.PWRM_IDLEDOMAINS && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: (self.PWRM_EMIF = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update(), "ok")
    }
    global PWRM_CLKGEN :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CLKGEN"
        prop JSName :: "IDLECLKGEN"
        prop Visible :: 1
        prop Writable :: self.PWRM_IDLEDOMAINS && self.PWRM_ENABLE && self.PWRM_CPU && self.PWRM_CACHE && self.PWRM_DMA
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ($e = "ok", if ($1 == 1) {if (self.PWRM_DMA == 0) {$e = self.error("The DMA domain must be idled before idling CLKGEN")} else {if (self.PWRM_CPU == 0) {$e = self.error("The CPU domain must be idled before idling CLKGEN")} else {if (self.PWRM_CACHE == 0) {$e = self.error("The CACHE domain must be idled before idling CLKGEN")} else {self.PWRM_CLKGEN = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}}}} else {self.PWRM_CLKGEN = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}, $e)
    }
    global PWRM_PERIPH :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    PERIPHS"
        prop JSName :: "IDLEPERIPH"
        prop Visible :: 1
        prop Writable :: self.PWRM_IDLEDOMAINS && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: (self.PWRM_PERIPH = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update(), "ok")
    }
    global PWRM_CACHE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CACHE"
        prop JSName :: "IDLECACHE"
        prop Visible :: GBL.DSPSUBTYPE != 5509
        prop Writable :: self.PWRM_IDLEDOMAINS && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_CLKGEN == 1) {$e = self.error("The CACHE domain must remain idled while CLKGEN is idled")} else {self.PWRM_CACHE = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}} else {self.PWRM_CACHE = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}, $e)
    }
    global PWRM_DMA :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DMA"
        prop JSName :: "IDLEDMA"
        prop Visible :: 1
        prop Writable :: self.PWRM_IDLEDOMAINS && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_CLKGEN == 1) {$e = self.error("The DMA domain must remain idled while CLKGEN is idled")} else {self.PWRM_DMA = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}} else {self.PWRM_DMA = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}, $e)
    }
    global PWRM_CPU :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CPU"
        prop JSName :: "IDLECPU"
        prop Visible :: 1
        prop Writable :: self.PWRM_IDLEDOMAINS && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_CLKGEN == 1) {$e = self.error("The CPU domain must remain idled while CLKGEN is idled")} else {self.PWRM_CPU = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}} else {self.PWRM_CPU = $1, self.PWRM_IDLEMASK = self.PWRM_idlemask_update()}, $e)
    }
    global PWRM_IDLEMASK :: 5 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock domain bitmask for IDL loop"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: self.PWRM_IDLEDOMAINS
        prop NoGen :: 0
        prop TabName :: "Idling"
    }
    global PWRM_CAPSMASK :: 35 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PWRM caps mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global PWRM_SCALING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Voltage and Frequency Scaling"
        prop JSName :: "SCALING"
        prop Visible :: 1
        prop Writable :: (self.PWRM_ENABLE && (GBL.MEMORYMODEL == "LARGE") && (GBL.DSPSUBTYPE == 5503 || GBL.DSPSUBTYPE == 5507 || GBL.DSPSUBTYPE == 5509 || GBL.DSPSUBTYPE == 5510))
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
        prop Set :: (self.PWRM_SCALING = $1, if ($1 == 0) {self.PWRM_ADAPTCLK = 0} , self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_INITSP :: 15 { 
        prop Label :: "Initial frequency (index to frequency table)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "INITIALFREQ"
        prop Visible :: 1
        prop Writable :: self.PWRM_SCALING && self.PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
    }
    global PWRM_INITVOLTS :: 1.600000 { 
        prop Label :: "Initial voltage (volts)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.2f"
        prop JSName :: "INITVOLTS"
        prop Visible :: 1
        prop Writable :: self.PWRM_SCALING && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
    }
    global PWRM_INITMILVOLTS :: = int(round(self.PWRM_INITVOLTS * 1000)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PWRM_SCALEV :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Scale voltage along with frequency"
        prop JSName :: "SCALEVOLT"
        prop Visible :: 1
        prop Writable :: self.PWRM_SCALING && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: (self.PWRM_SCALEV = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_WAITV :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Wait while voltage is being scaled down"
        prop JSName :: "WAITVOLT"
        prop Visible :: 1
        prop Writable :: self.PWRM_SCALING && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: (self.PWRM_WAITV = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_CONFIGLIB :: = self.pslConfigLibName() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "PSL Configuration Library"
        prop JSName :: "PSLCONFIGLIB"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE == 1 && self.PWRM_SCALING == 1 && GBL.MEMORYMODEL == "LARGE"
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: ($e = "ok", if ($1 == "") {$e = "A PSL configuration library name must be entered"} else {self.PWRM_CONFIGLIB = $1}, $e)
    }
    global PWRM_ENSLEEP :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable deep sleep"
        prop JSName :: "ENABLESLEEP"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (self.PWRM_ENSLEEP = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_DS_EMIF :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    EMIF"
        prop JSName :: "SLEEPEMIF"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (self.PWRM_DS_EMIF = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update(), "ok")
    }
    global PWRM_DS_CLKGEN :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CLKGEN"
        prop JSName :: "SLEEPCLKGEN"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE && self.PWRM_DS_CPU && self.PWRM_DS_CACHE && self.PWRM_DS_DMA
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ($e = "ok", if ($1 == 1) {if (self.PWRM_DS_DMA == 0) {$e = self.error("The DMA domain must be idled before idling CLKGEN")} else {if (self.PWRM_DS_CPU == 0) {$e = self.error("The CPU domain must be idled before idling CLKGEN")} else {if (self.PWRM_DS_CACHE == 0) {$e = self.error("The CACHE domain must be idled before idling CLKGEN")} else {self.PWRM_DS_CLKGEN = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}}}} else {self.PWRM_DS_CLKGEN = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}, $e)
    }
    global PWRM_DS_PERIPH :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    PERIPHS"
        prop JSName :: "SLEEPPERIPH"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (self.PWRM_DS_PERIPH = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update(), "ok")
    }
    global PWRM_DS_CACHE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CACHE"
        prop JSName :: "SLEEPCACHE"
        prop Visible :: GBL.DSPSUBTYPE != 5509
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_DS_CLKGEN == 1) {$e = self.error("The CACHE domain must remain idled while CLKGEN is idled")} else {self.PWRM_DS_CACHE = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}} else {self.PWRM_DS_CACHE = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}, $e)
    }
    global PWRM_DS_DMA :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DMA"
        prop JSName :: "SLEEPDMA"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_DS_CLKGEN == 1) {$e = self.error("The DMA domain must remain idled while CLKGEN is idled")} else {self.PWRM_DS_DMA = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}} else {self.PWRM_DS_DMA = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}, $e)
    }
    global PWRM_DS_CPU :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CPU"
        prop JSName :: "SLEEPCPU"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ($e = "ok", if ($1 == 0) {if (self.PWRM_DS_CLKGEN == 1) {$e = self.error("The CPU domain must remain idled while CLKGEN is idled")} else {self.PWRM_DS_CPU = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}} else {self.PWRM_DS_CPU = $1, self.PWRM_DS_IDLEMASK = self.PWRM_DS_idlemask_update()}, $e)
    }
    global PWRM_DS_IDLEMASK :: 63 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock domain bitmask for deep sleep"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: self.PWRM_ENSLEEP
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    global PWRM_IER0 :: 0 { 
        prop Label :: "Wakeup interrupt mask, IER0"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop JSName :: "WKUPIER0"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    global PWRM_IER1 :: 0 { 
        prop Label :: "Wakeup interrupt mask, IER1"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop JSName :: "WKUPIER1"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSLEEP && self.PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    global PWRM_ENSLEEPUNTILRESTART :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable sleep until restart"
        prop JSName :: "SLEEPUNTILRESTART"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (self.PWRM_ENSLEEPUNTILRESTART = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_ENSNOOZE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable snooze mode"
        prop JSName :: "ENABLESNOOZE"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (self.PWRM_ENSNOOZE = $1, self.PWRM_CAPSMASK = self.PWRM_capsmask_update(), "ok")
    }
    global PWRM_WHICHTIMER :: "Timer 1" { 
        prop Label :: "Timer to be used for snooze mode:"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1"
        prop JSName :: "TIMERFORSNOOZE"
        prop Visible :: 1
        prop Writable :: self.PWRM_ENSNOOZE
        prop NoGen :: 1
        prop TabName :: "Sleep"
    }
}

object PWRM_idleDomains :: IDL {
    param iComment :: "This object idles select clock domains from the BIOS IDL loop "
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is used by PWRM and can't be deleted"
    param function :: @_FXN_F_nop
    param cycles :: 0
    param calibration :: 0
    param Order :: 0
    param iPri :: 0
}

object NOR :: MEM {
    param iComment :: "NOR Flash"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 4194304
    param len :: 2097152
    param iAllocHeap :: 0
    param iHeapSize :: 16336
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object NAND :: MEM {
    param iComment :: "NAND Flash"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 7340032
    param len :: 524288
    param iAllocHeap :: 0
    param iHeapSize :: 16336
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object SRAM :: MEM {
    param iComment :: "External SRAM"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 163840
    param len :: 4030464
    param iAllocHeap :: 0
    param iHeapSize :: 16336
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object DARAM :: MEM {
    param iComment :: "8 blocks of 8K bytes on-chip Dual Access RAM"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 96
    param len :: 32544
    param iAllocHeap :: 1
    param iHeapSize :: 1280
    param iUserHeapId :: 1
    param iHeapId :: @_SEG0
    param iReqHeapCount :: 2
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object SARAM :: MEM {
    param iComment :: "32 blocks of 8K bytes on-chip Single Access RAM"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 32768
    param len :: 131072
    param iAllocHeap :: 0
    param iHeapSize :: 16336
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object trace :: LOG {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param buflen :: 1024
    param logtype :: "circular"
    param iType :: "printf"
    param iFormat :: "0x%x, 0x%x, 0x%x"
}

